<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Gappy-svn] r2 - trunk/support/emacs
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/gappy-svn/2005-November/index.html" >
   <LINK REL="made" HREF="mailto:gappy-svn%40lists.berlios.de?Subject=Re%3A%20%5BGappy-svn%5D%20r2%20-%20trunk/support/emacs&In-Reply-To=%3C200511012355.jA1NtmpM010364%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000000.html">
   <LINK REL="Next"  HREF="000002.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Gappy-svn] r2 - trunk/support/emacs</H1>
    <B>Benjamin Pollack at BerliOS</B> 
    <A HREF="mailto:gappy-svn%40lists.berlios.de?Subject=Re%3A%20%5BGappy-svn%5D%20r2%20-%20trunk/support/emacs&In-Reply-To=%3C200511012355.jA1NtmpM010364%40sheep.berlios.de%3E"
       TITLE="[Gappy-svn] r2 - trunk/support/emacs">gecko at berlios.de
       </A><BR>
    <I>Wed Nov  2 00:55:48 CET 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000000.html">[Gappy-svn] Google Groups: You've been added to DukeOSSHouseCourse
</A></li>
        <LI>Next message: <A HREF="000002.html">[Gappy-svn] r3 - trunk/support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1">[ date ]</a>
              <a href="thread.html#1">[ thread ]</a>
              <a href="subject.html#1">[ subject ]</a>
              <a href="author.html#1">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gecko
Date: 2005-11-02 00:55:29 +0100 (Wed, 02 Nov 2005)
New Revision: 2

Added:
   trunk/support/emacs/doctest-mode.el
   trunk/support/emacs/pycomplete.el
   trunk/support/emacs/pycomplete.py
   trunk/support/emacs/python-mode.el
Log:
Adds Python mode to the repository for anyone using Python. This is added primarily to test whether the mailing lists and commit notifications have all been properly configured.


Added: trunk/support/emacs/doctest-mode.el
===================================================================
--- trunk/support/emacs/doctest-mode.el	2005-11-01 21:07:33 UTC (rev 1)
+++ trunk/support/emacs/doctest-mode.el	2005-11-01 23:55:29 UTC (rev 2)
@@ -0,0 +1,919 @@
+;;; doctest-mode.el --- Major mode for editing Python doctest files
+
+;; Copyright (C) 2004  Edward Loper
+
+;; Author:     Edward Loper
+;; Maintainer: <A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">edloper at alum.mit.edu</A>
+;; Created:    Aug 2004
+;; Keywords:   python doctest unittest test docstring
+
+(defconst doctest-version &quot;0.2&quot;
+  &quot;`doctest-mode' version number.&quot;)
+
+;; This software is provided as-is, without express or implied
+;; warranty.  Permission to use, copy, modify, distribute or sell this
+;; software, without fee, for any purpose and by any individual or
+;; organization, is hereby granted, provided that the above copyright
+;; notice and this paragraph appear in all copies.
+
+;; This is a major mode for editing text files that contain Python
+;; doctest examples.  Doctest is a testing framework for Python that
+;; emulates an interactive session, and checks the result of each
+;; command.  For more information, see the Python library reference:
+;; &lt;<A HREF="http://docs.python.org/lib/module-doctest.html">http://docs.python.org/lib/module-doctest.html</A>&gt;
+
+;; Known bugs:
+;; - Some places assume prompts are 4 chars (but they can be 3
+;;   if they're bare).
+;; - String literals are not colored correctly.  (We need to color
+;;   string literals on source lines, but *not* output lines or
+;;   text lines; this is hard to do.)
+;; - Output lines starting with &quot;...&quot; are mistakenly interpreted
+;;   as (continuation) source lines.
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Customizable Constants
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(defgroup doctest nil
+  &quot;Support for the Python doctest framework&quot;
+  :group 'languages
+  :prefix &quot;doctest-&quot;)
+
+(defcustom doctest-default-margin 4
+  &quot;The default pre-prompt margin for doctest examples.&quot;
+  :type 'integer
+  :group 'doctest)
+
+(defcustom doctest-avoid-trailing-whitespace t
+  &quot;If true, then delete trailing whitespace when inserting a newline.&quot;
+  :type 'boolean
+  :group 'doctest)
+
+(defcustom doctest-temp-directory
+  (let ((ok '(lambda (x)
+	       (and x
+		    (setq x (expand-file-name x)) ; always true
+		    (file-directory-p x)
+		    (file-writable-p x)
+		    x))))
+    (or (funcall ok (getenv &quot;TMPDIR&quot;))
+	(funcall ok &quot;/usr/tmp&quot;)
+	(funcall ok &quot;/tmp&quot;)
+	(funcall ok &quot;/var/tmp&quot;)
+	(funcall ok  &quot;.&quot;)
+	(error (concat &quot;Couldn't find a usable temp directory -- &quot;
+		       &quot;set `doctest-temp-directory'&quot;))))
+	 
+  &quot;*Directory used for temporary files created when running doctest.
+By default, the first directory from this list that exists and that you
+can write into: the value (if any) of the environment variable TMPDIR,
+/usr/tmp, /tmp, /var/tmp, or the current directory.&quot;
+  :type 'string
+  :group 'doctest)
+
+(defcustom hide-example-source t
+  &quot;If true, then don't display the example source code for each 
+failure in the results buffer.&quot;
+  :type 'boolean
+  :group 'doctest)
+
+(defcustom doctest-python-command &quot;python&quot;
+  &quot;Shell command used to start the python interpreter&quot;)
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Fonts
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(defface doctest-prompt-face
+  '((((class color) (background dark))
+     (:foreground &quot;#68f&quot;))
+    (t (:foreground &quot;#226&quot;)))
+  &quot;Face for Python prompts in doctest examples.&quot;
+  :group 'doctest)
+
+(defface doctest-output-face
+  '((((class color) (background dark))
+     (:foreground &quot;#afd&quot;))
+    (t (:foreground &quot;#262&quot;)))
+  &quot;Face for the output of doctest examples.&quot;
+  :group 'doctest)
+
+(defface doctest-output-marker-face
+  '((((class color) (background dark))
+     (:foreground &quot;#0f0&quot;))
+    (t (:foreground &quot;#080&quot;)))
+  &quot;Face for markers in the output of doctest examples.&quot;
+  :group 'doctest)
+
+(defface doctest-output-traceback-face
+  '((((class color) (background dark))
+     (:foreground &quot;#f88&quot;))
+    (t (:foreground &quot;#622&quot;)))
+  &quot;Face for traceback headers in the output of doctest examples.&quot;
+  :group 'doctest)
+
+(defface doctest-results-divider-face
+  '((((class color) (background dark))
+     (:foreground &quot;#08f&quot;))
+    (t (:foreground &quot;#00f&quot;)))
+  &quot;Face for dividers in the doctest results window.&quot;
+  :group 'doctest)
+
+(defface doctest-results-loc-face
+  '((((class color) (background dark))
+     (:foreground &quot;#0f8&quot;))
+    (t (:foreground &quot;#084&quot;)))
+  &quot;Face for location headers in the doctest results window.&quot;
+  :group 'doctest)
+
+(defface doctest-results-header-face
+  '((((class color) (background dark))
+     (:foreground &quot;#8ff&quot;))
+    (t (:foreground &quot;#088&quot;)))
+  &quot;Face for sub-headers in the doctest results window.&quot;
+  :group 'doctest)
+
+(defface doctest-results-selection-face
+  '((((class color) (background dark))
+     (:foreground &quot;#ff0&quot; :background &quot;#008&quot;))
+    (t (:background &quot;#088&quot; :foreground &quot;#fff&quot;)))
+  &quot;Face for selected failure's location header in the results window.&quot;
+  :group 'doctest)
+
+(defface doctest-selection-face
+  '((((class color) (background dark))
+     (:foreground &quot;#ff0&quot; :background &quot;#00f&quot; :bold t))
+    (t (:foreground &quot;#f00&quot;)))
+  &quot;Face for selected example's prompt&quot;
+  :group 'doctest)
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Constants
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(defconst doctest-prompt-re
+  &quot;^\\([ \t]*\\)\\(&gt;&gt;&gt; ?\\|[.][.][.] ?\\)\\([ \t]*\\)&quot;
+  &quot;Regular expression for doctest prompts.  It defines three groups:
+the pre-prompt margin; the prompt; and the post-prompt indentation.&quot;)
+
+(defconst doctest-open-block-re
+  &quot;[^\n]+:[ \t]*\\(#.*\\)?$&quot;
+  &quot;Regular expression for a line that opens a block&quot;)
+
+(defconst doctest-close-block-re
+  &quot;\\(return\\|raise\\|break\\|continue\\|pass\\)\\b&quot;
+  &quot;Regular expression for a line that closes a block&quot;)
+
+(defconst doctest-outdent-re
+  (concat &quot;\\(&quot; (mapconcat 'identity
+			   '(&quot;else:&quot;
+			     &quot;except\\(\\s +.*\\)?:&quot;
+			     &quot;finally:&quot;
+			     &quot;elif\\s +.*:&quot;)
+			   &quot;\\|&quot;)
+	  &quot;\\)&quot;)
+  &quot;Regular expression for a line that should be outdented.  Any line
+that matches `doctest-outdent-re', but does not follow a line matching
+`doctest-no-outdent-re', will be outdented.&quot;)
+
+(defconst doctest-no-outdent-re
+  (concat
+   &quot;\\(&quot;
+   (mapconcat 'identity
+	      (list &quot;try:&quot;
+		    &quot;except\\(\\s +.*\\)?:&quot;
+		    &quot;while\\s +.*:&quot;
+		    &quot;for\\s +.*:&quot;
+		    &quot;if\\s +.*:&quot;
+		    &quot;elif\\s +.*:&quot;
+                    &quot;\\(return\\|raise\\|break\\|continue\\|pass\\)[ \t\n]&quot;
+		    )
+	      &quot;\\|&quot;)
+	  &quot;\\)&quot;)
+  &quot;Regular expression matching lines not to outdent after.  Any line
+that matches `doctest-outdent-re', but does not follow a line matching
+`doctest-no-outdent-re', will be outdented.&quot;)
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Colorization support (font-lock mode)
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; Define the font-lock keyword table.
+(defconst doctest-font-lock-keywords
+  (let ((prompt &quot;^[ \t]*\\(&gt;&gt;&gt;\\|\\.\\.\\.\\)&quot;)
+        (kw1 (mapconcat 'identity
+			'(&quot;and&quot;      &quot;assert&quot;   &quot;break&quot;   &quot;class&quot;
+			  &quot;continue&quot; &quot;def&quot;      &quot;del&quot;     &quot;elif&quot;
+			  &quot;else&quot;     &quot;except&quot;   &quot;exec&quot;    &quot;for&quot;
+			  &quot;from&quot;     &quot;global&quot;   &quot;if&quot;      &quot;import&quot;
+			  &quot;in&quot;       &quot;is&quot;       &quot;lambda&quot;  &quot;not&quot;
+			  &quot;or&quot;       &quot;pass&quot;     &quot;print&quot;   &quot;raise&quot;
+			  &quot;return&quot;   &quot;while&quot;    &quot;yield&quot;
+			  )
+			&quot;\\|&quot;))
+	(kw2 (mapconcat 'identity
+			'(&quot;else:&quot; &quot;except:&quot; &quot;finally:&quot; &quot;try:&quot;)
+			&quot;\\|&quot;))
+	(kw3 (mapconcat 'identity
+			'(&quot;ArithmeticError&quot; &quot;AssertionError&quot;
+			  &quot;AttributeError&quot; &quot;DeprecationWarning&quot; &quot;EOFError&quot;
+			  &quot;Ellipsis&quot; &quot;EnvironmentError&quot; &quot;Exception&quot; &quot;False&quot;
+			  &quot;FloatingPointError&quot; &quot;FutureWarning&quot; &quot;IOError&quot;
+			  &quot;ImportError&quot; &quot;IndentationError&quot; &quot;IndexError&quot;
+			  &quot;KeyError&quot; &quot;KeyboardInterrupt&quot; &quot;LookupError&quot;
+			  &quot;MemoryError&quot; &quot;NameError&quot; &quot;None&quot; &quot;NotImplemented&quot;
+			  &quot;NotImplementedError&quot; &quot;OSError&quot; &quot;OverflowError&quot;
+			  &quot;OverflowWarning&quot; &quot;PendingDeprecationWarning&quot;
+			  &quot;ReferenceError&quot; &quot;RuntimeError&quot; &quot;RuntimeWarning&quot;
+			  &quot;StandardError&quot; &quot;StopIteration&quot; &quot;SyntaxError&quot;
+			  &quot;SyntaxWarning&quot; &quot;SystemError&quot; &quot;SystemExit&quot;
+			  &quot;TabError&quot; &quot;True&quot; &quot;TypeError&quot; &quot;UnboundLocalError&quot;
+			  &quot;UnicodeDecodeError&quot; &quot;UnicodeEncodeError&quot;
+			  &quot;UnicodeError&quot; &quot;UnicodeTranslateError&quot;
+			  &quot;UserWarning&quot; &quot;ValueError&quot; &quot;Warning&quot;
+			  &quot;ZeroDivisionError&quot; &quot;__debug__&quot;
+			  &quot;__import__&quot; &quot;__name__&quot; &quot;abs&quot; &quot;apply&quot; &quot;basestring&quot;
+			  &quot;bool&quot; &quot;buffer&quot; &quot;callable&quot; &quot;chr&quot; &quot;classmethod&quot;
+			  &quot;cmp&quot; &quot;coerce&quot; &quot;compile&quot; &quot;complex&quot; &quot;copyright&quot;
+			  &quot;delattr&quot; &quot;dict&quot; &quot;dir&quot; &quot;divmod&quot;
+			  &quot;enumerate&quot; &quot;eval&quot; &quot;execfile&quot; &quot;exit&quot; &quot;file&quot;
+			  &quot;filter&quot; &quot;float&quot; &quot;getattr&quot; &quot;globals&quot; &quot;hasattr&quot;
+			  &quot;hash&quot; &quot;hex&quot; &quot;id&quot; &quot;input&quot; &quot;int&quot; &quot;intern&quot;
+			  &quot;isinstance&quot; &quot;issubclass&quot; &quot;iter&quot; &quot;len&quot; &quot;license&quot;
+			  &quot;list&quot; &quot;locals&quot; &quot;long&quot; &quot;map&quot; &quot;max&quot; &quot;min&quot; &quot;object&quot;
+			  &quot;oct&quot; &quot;open&quot; &quot;ord&quot; &quot;pow&quot; &quot;property&quot; &quot;range&quot;
+			  &quot;raw_input&quot; &quot;reduce&quot; &quot;reload&quot; &quot;repr&quot; &quot;round&quot;
+			  &quot;setattr&quot; &quot;slice&quot; &quot;staticmethod&quot; &quot;str&quot; &quot;sum&quot;
+			  &quot;super&quot; &quot;tuple&quot; &quot;type&quot; &quot;unichr&quot; &quot;unicode&quot; &quot;vars&quot;
+			  &quot;xrange&quot; &quot;zip&quot;)
+			&quot;\\|&quot;))
+        (pseudokw (mapconcat 'identity
+                        '(&quot;self&quot; &quot;None&quot; &quot;True&quot; &quot;False&quot; &quot;Ellipsis&quot;)
+                        &quot;\\|&quot;))
+        (brk &quot;\\([ \t(]\\|$\\)&quot;)
+	)
+    `(
+      ;; The following pattern colorizes source lines.  In particular,
+      ;; it first matches prompts, and then looks for any of the
+      ;; following matches *on the same line* as the prompt.  It uses
+      ;; the form:
+      ;;
+      ;;   (MATCHER MATCH-HIGHLIGHT
+      ;;            (ANCHOR-MATCHER nil nil MATCH-HIGHLIGHT)
+      ;;            ...
+      ;;            (ANCHOR-MATCHER nil nil MATCH-HIGHLIGHT))
+      ;;
+      ;; See the variable documentation for font-lock-keywords for a
+      ;; description of what each of those means.
+      (,prompt (1 'doctest-prompt-face)
+               ;; classes
+               (&quot;\\b\\(class\\)[ \t]+\\([a-zA-Z_]+[a-zA-Z0-9_]*\\)&quot;
+                nil nil (1 'font-lock-keyword-face)
+                (2 'font-lock-type-face))
+               ;; functions
+               (&quot;\\b\\(def\\)[ \t]+\\([a-zA-Z_]+[a-zA-Z0-9_]*\\)&quot;
+                nil nil (1 'font-lock-keyword-face) (2 'font-lock-type-face))
+               ;; keywords
+               (,(concat &quot;\\b\\(&quot; kw1 &quot;\\)&quot; brk)
+                nil nil (1 'font-lock-keyword-face))
+               ;; builtins when they don't appear as object attributes
+               (,(concat &quot;\\(\\b\\|[.]\\)\\(&quot; kw3 &quot;\\)&quot; brk)
+                nil nil (2 'font-lock-keyword-face))
+               ;; block introducing keywords with immediately
+               ;; following colons.  Yes &quot;except&quot; is in both lists.
+               (,(concat &quot;\\b\\(&quot; kw2 &quot;\\)&quot; brk)
+                nil nil (1 'font-lock-keyword-face))
+               ;; `as' but only in &quot;import foo as bar&quot;
+               (&quot;[ \t]*\\(\\bfrom\\b.*\\)?\\bimport\\b.*\\b\\(as\\)\\b&quot;
+                nil nil (2 'font-lock-keyword-face))
+               ;; pseudo-keywords
+               (,(concat &quot;\\b\\(&quot; pseudokw &quot;\\)&quot; brk)
+                nil nil (1 'font-lock-keyword-face))
+               ;; comments
+               (&quot;\\(#.*\\)&quot;
+                nil nil (1 'font-lock-comment-face)))
+
+      ;; The following pattern colorizes output lines.  In particular,
+      ;; it uses doctest-output-line-matcher to check if this is an
+      ;; output line, and if so, it colorizes it, and any special
+      ;; markers it contains.
+      (doctest-output-line-matcher
+       (0 'doctest-output-face t)
+       (&quot;\\.\\.\\.&quot; (beginning-of-line) (end-of-line)
+	(0 'doctest-output-marker-face t))
+       (&quot;&lt;BLANKLINE&gt;&quot; (beginning-of-line) (end-of-line)
+	(0 'doctest-output-marker-face t))
+       (&quot;^Traceback (most recent call last):&quot; (beginning-of-line) (end-of-line)
+	(0 'doctest-output-traceback-face t))
+       (&quot;^Traceback (innermost last):&quot; (beginning-of-line) (end-of-line)
+	(0 'doctest-output-traceback-face t))
+       )
+
+      ;; A PS1 prompt followed by a non-space is an error.
+      (&quot;^[ \t]*\\(&gt;&gt;&gt;[^ \t\n][^\n]*\\)&quot; (1 'font-lock-warning-face t))
+
+      ;; Selected example (to highlight selected failure)
+      (doctest-selection-matcher (0 'doctest-selection-face t))
+      ))
+  &quot;Expressions to highlight in Doctest mode.&quot;)
+
+(defun doctest-output-line-matcher (limit)
+  &quot;A `font-lock-keyword' MATCHER that returns t if the current 
+line is the expected output for a doctest example, and if so, 
+sets `match-data' so that group 0 spans the current line.&quot;
+  ;; The real work is done by find-doctest-output-line.
+  (when (find-doctest-output-line limit)
+    ;; If we found one, then mark the entire line.
+    (beginning-of-line)
+    (search-forward-regexp &quot;[^\n]*&quot; limit)))
+
+;; [XX] Under construction.
+(defun doctest-selection-matcher (limit)
+  (let (found-it)
+    (while (and (not found-it) 
+                (search-forward-regexp &quot;^[ \t]*\\(&gt;&gt;&gt;\\|[.][.][.]\\)&quot;
+                                       limit t))
+      (if (get-text-property (point) 'doctest-selected)
+          (setq found-it t)))
+    found-it))
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Source line indentation
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(defun doctest-indent-source-line (&amp;optional dedent-only)
+  &quot;Re-indent the current line, as doctest source code.  I.e., add a
+prompt to the current line if it doesn't have one, and re-indent the
+source code (to the right of the prompt).  If `dedent-only' is true,
+then don't increase the indentation level any.&quot;
+  (interactive &quot;*&quot;)
+  (let ((indent-end nil))
+    (save-excursion
+      (beginning-of-line)
+      (let ((new-indent (doctest-current-source-line-indentation dedent-only))
+            (new-margin (doctest-current-source-line-margin))
+            (line-had-prompt (looking-at doctest-prompt-re)))
+        ;; Delete the old prompt (if any).
+        (when line-had-prompt
+          (goto-char (match-end 1))
+          (delete-char 4))
+        ;; Delete the old indentation.
+        (delete-backward-char (skip-chars-forward &quot; \t&quot;))
+        ;; If it's a continuation line, or a new PS1 prompt,
+        ;; then copy the margin.
+        (when (or new-indent (not line-had-prompt))
+          (beginning-of-line)
+          (delete-backward-char (skip-chars-forward &quot; \t&quot;))
+          (insert-char ?\  new-margin))
+        ;; Add the new prompt.
+        (insert-string (if new-indent &quot;... &quot; &quot;&gt;&gt;&gt; &quot;))
+        ;; Add the new indentation
+        (if new-indent (insert-char ?\  new-indent))
+        (setq indent-end (point))))
+    ;; If we're left of the indentation end, then move up to the
+    ;; indentation end.
+    (if (&lt; (point) indent-end) (goto-char indent-end))))
+
+(defun doctest-current-source-line-indentation (&amp;optional dedent-only)
+  &quot;Return the post-prompt indent to use for this line.  This is an
+integer for a continuation lines, and nil for non-continuation lines.&quot;
+  (save-excursion
+    (let ((prev-line-indent 0)
+          (curr-line-indent 0)
+          (prev-line-opens-block nil)
+          (prev-line-closes-block nil)
+          (curr-line-outdented nil))
+      ;; Examine this doctest line.
+      (beginning-of-line)
+      (when (looking-at doctest-prompt-re)
+          (setq curr-line-indent (- (match-end 3) (match-beginning 3)))
+	  (goto-char (match-end 3)))
+      (setq curr-line-outdented (looking-at doctest-outdent-re))
+      ;; Examine the previous line.
+      (when (= (forward-line -1) 0) ; move up a line
+	(when (looking-at doctest-prompt-re) ; is it a source line?
+	  (let ((indent-beg (column-at-char (match-beginning 3)))
+		(indent-end (column-at-char (match-end 3))))
+	    (setq prev-line-indent (- indent-end indent-beg))
+	    (goto-char (match-end 3))
+	    (if (looking-at doctest-open-block-re)
+		(setq prev-line-opens-block t))
+	    (if (looking-at doctest-close-block-re)
+		(setq prev-line-closes-block t))
+	    (if (looking-at doctest-no-outdent-re)
+		(setq curr-line-outdented nil))
+	    )))
+      (let ((indent (+ prev-line-indent
+                       (if curr-line-outdented -4 0)
+                       (if prev-line-opens-block 4 0)
+                       (if prev-line-closes-block -4 0))))
+	;; If dedent-only is true, then make sure we don't indent.
+	(when dedent-only 
+	  (setq indent (min indent curr-line-indent)))
+	;; If indent=0 and we're not outdented, then set indent to
+	;; nil (to signify the start of a new source example).
+	(when (and (= indent 0) (not curr-line-outdented))
+	  (setq indent nil))
+	;; Return the indentation.
+	indent))))
+
+(defun doctest-current-source-line-margin ()
+  &quot;Return the pre-prompt margin to use for this source line.  This is
+copied from the most recent source line, or set to
+`doctest-default-margin' if there are no preceeding source lines.&quot;
+  (save-excursion
+    (beginning-of-line)
+    (if (search-backward-regexp doctest-prompt-re nil t)
+        (let ((margin-beg (column-at-char (match-beginning 1)))
+              (margin-end (column-at-char (match-end 1))))
+          (- margin-end margin-beg))
+      doctest-default-margin)))
+
+(defun doctest-electric-backspace ()
+  &quot;Delete the preceeding character, level of indentation, or
+prompt.  
+
+If point is at the leftmost column, delete the preceding newline.
+
+Otherwise, if point is at the first non-whitespace character
+following an indented source line's prompt, then reduce the
+indentation to the next multiple of 4; and update the source line's
+prompt, when necessary.
+
+Otherwise, if point is at the first non-whitespace character
+following an unindented source line's prompt, then remove the
+prompt (converting the line to an output line or text line).
+
+Otherwise, if point is at the first non-whitespace character of a
+line, the delete the line's indentation.
+
+Otherwise, delete the preceeding character.
+&quot;
+  (interactive &quot;*&quot;)
+  (cond 
+   ;; Beginning of line: delete preceeding newline.
+   ((bolp) (backward-delete-char 1))
+      
+   ;; First non-ws char following prompt: dedent or remove prompt.
+   ((and (looking-at &quot;[^ \t\n]\\|$&quot;) (doctest-looking-back doctest-prompt-re))
+    (let* ((prompt-beg (match-beginning 2))
+	   (indent-beg (match-beginning 3)) (indent-end (match-end 3))
+	   (old-indent (- indent-end indent-beg))
+	   (new-indent (* (/ (- old-indent 1) 4) 4)))
+      (cond
+       ;; Indented source line: dedent it.
+       ((&gt; old-indent 0)
+	(goto-char indent-beg)
+	(delete-region indent-beg indent-end)
+	(insert-char ?\  new-indent)
+	;; Change prompt to PS1, when appropriate.
+	(when (and (= new-indent 0) (not (looking-at doctest-outdent-re)))
+	  (delete-backward-char 4)
+	  (insert-string &quot;&gt;&gt;&gt; &quot;)))
+       ;; Non-indented source line: remove prompt.
+       (t
+	(goto-char indent-end)
+	(delete-region prompt-beg indent-end)))))
+
+   ;; First non-ws char of a line: delete all indentation.
+   ((and (looking-at &quot;[^ \n\t]\\|$&quot;) (doctest-looking-back &quot;^[ \t]+&quot;))
+    (delete-region (match-beginning 0) (match-end 0)))
+
+   ;; Otherwise: delete a character.
+   (t
+    (backward-delete-char 1))))
+
+(defun doctest-newline-and-indent ()
+  &quot;Insert a newline, and indent the new line appropriately.
+
+If the current line is a source line containing a bare prompt,
+then clear the current line, and insert a newline.
+
+Otherwise, if the current line is a source line, then insert a
+newline, and add an appropriately indented prompt to the new
+line.
+
+Otherwise, if the current line is an output line, then insert a
+newline and indent the new line to match the example's margin.
+
+Otherwise, insert a newline.
+
+If `doctest-avoid-trailing-whitespace' is true, then clear any
+whitespace to the left of the point before inserting a newline.
+&quot;
+  (interactive &quot;*&quot;)
+  ;; If we're avoiding trailing spaces, then delete WS before point.
+  (if doctest-avoid-trailing-whitespace
+      (delete-char (- (skip-chars-backward &quot; \t&quot;))))     
+  (cond 
+   ;; If we're on an empty prompt, delete it.
+   ((on-empty-doctest-source-line)
+    (delete-region (match-beginning 0) (match-end 0))
+    (insert-char ?\n 1))
+   ;; If we're on a doctest line, add a new prompt.
+   ((on-doctest-source-line)
+    (insert-char ?\n 1)
+    (doctest-indent-source-line))
+   ;; If we're in doctest output, indent to the margin.
+   ((on-doctest-output-line)
+    (insert-char ?\n 1)
+    (insert-char ?\  (doctest-current-source-line-margin)))
+   ;; Otherwise, just add a newline.
+   (t (insert-char ?\n 1))))
+
+(defun doctest-electric-colon ()
+  &quot;Insert a colon, and dedent the line when appropriate.&quot;
+  (interactive &quot;*&quot;)
+  (insert-char ?: 1)
+  (when (on-doctest-source-line)
+    (doctest-indent-source-line t)))
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Code Execution
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; Add support for options (eg diff!)
+(defun doctest-execute-buffer ()
+  &quot;Run doctest on the current buffer, and display the results in the 
+*doctest-output* buffer.&quot;
+  (interactive &quot;*&quot;)
+  (setq doctest-results-buffer (get-buffer-create &quot;*doctest-output*&quot;))
+  (let* ((temp (concat (doctest-temp-name) &quot;.py&quot;))
+	 (tempfile (expand-file-name temp doctest-temp-directory))
+	 (cur-buf (current-buffer))
+	 (in-buf (get-buffer-create &quot;*doctest-input*&quot;))
+	 (beg (point-min)) (end (point-max))
+	 (script (concat &quot;from doctest import *\n&quot;
+			 &quot;doc = open('&quot; tempfile &quot;').read()\n&quot;
+			 &quot;test = DocTestParser().get_doctest(&quot;
+			         &quot;doc, {}, '&quot; (buffer-name) &quot;', '&quot;
+				 (buffer-file-name) &quot;', 0)\n&quot;
+			 &quot;r = DocTestRunner()\n&quot;
+			 &quot;r.run(test)\n&quot;))
+	 (cmd (concat doctest-python-command &quot; -c \&quot;&quot; script &quot;\&quot;&quot;)))
+    ;; Write buffer to a file.
+    (save-excursion
+      (set-buffer in-buf)
+      (insert-buffer-substring cur-buf beg end)
+      (write-file tempfile))
+    ;; Run doctest
+    (shell-command cmd doctest-results-buffer)
+    ;; Delete the temp file
+    (delete-file tempfile)
+    ;; Set mode on output buffer.
+    (save-excursion
+      (set-buffer doctest-results-buffer)
+      (doctest-results-mode))
+    ;; If any tests failed, display them.
+    (cond ((&gt; (buffer-size doctest-results-buffer) 0)
+	   (message &quot;Test failed!&quot;)
+	   (display-buffer doctest-results-buffer)
+	   (doctest-postprocess-results))
+	  (t
+	   (message &quot;Test passed!&quot;)
+	   (if (get-buffer-window doctest-results-buffer)
+	       (delete-window (get-buffer-window doctest-results-buffer)))))))
+
+(defun doctest-postprocess-results ()
+  (doctest-next-failure 1)
+  (if hide-example-source
+    (hide-example-source)))
+
+(defun doctest-next-failure (count)
+  &quot;Move to the top of the next failing example, and highlight the
+example's failure description in *doctest-output*.&quot;
+  (interactive &quot;p&quot;)
+  (let (lineno)
+    (cond
+     ((not (buffer-live-p doctest-results-buffer))
+      (message &quot;Run doctest first! (C-c C-c)&quot;))
+     (t
+      (save-excursion
+        (let ((orig-window (selected-window))
+              (results-window (display-buffer doctest-results-buffer)))
+          ;; Switch to the results window (so its point gets updated)
+          (if results-window (select-window results-window))
+          ;; Pick up where we left off.
+          ;; (nb: doctest-selected-failure is buffer-local)
+          (goto-char (or doctest-selected-failure (point-min)))
+          ;; Skip past anything on *this* line.
+          (if (&gt;= count 0) (end-of-line) (beginning-of-line))
+          ;; Look for the next failure
+          (if (&gt;= count 0)
+              (re-search-forward doctest-results-loc-re nil t count)
+            (re-search-backward doctest-results-loc-re nil t (- count)))
+          (cond
+           ;; We found a failure:
+           ((match-string 2)
+            (let ((old-selected-failure doctest-selected-failure))
+              ;; Extract the line number for the doctest file.
+              (setq lineno (string-to-int (match-string 2)))
+              ;; Store our position for next time.
+              (beginning-of-line)
+              (setq doctest-selected-failure (point))
+              ;; Update selection.
+              (doctest-fontify-line old-selected-failure)
+              (doctest-fontify-line doctest-selected-failure)))
+           ;; We didn't find a failure:
+           (t
+            (message &quot;No failures found!&quot;)))
+          ;; Return to the original window
+          (select-window orig-window)))))
+
+    (when lineno
+      ;; Move point to the selected failure.
+      (goto-line lineno)
+;      ;; Highlight it. [XX] Under construction.
+;      (let ((beg (save-excursion (beginning-of-line) (point)))
+;            (end (save-excursion (end-of-line) (point))))
+;        (add-text-properties (point-min) (point-max) '(doctest-selected nil))
+;        (add-text-properties beg end '(doctest-selected t))
+;        (doctest-fontify-line (point)))
+      )))
+
+(defun doctest-prev-failure (count)
+  &quot;Move to the top of the previous failing example, and highlight
+the example's failure description in *doctest-output*.&quot;
+  (interactive &quot;p&quot;)
+  (doctest-next-failure (- count)))
+
+(defun doctest-first-failure ()
+  (interactive &quot;&quot;)
+  (if (buffer-live-p doctest-results-buffer)
+      (save-excursion
+        (set-buffer doctest-results-buffer)
+        (let ((old-selected-failure doctest-selected-failure))
+          (setq doctest-selected-failure (point-min))
+          (doctest-fontify-line old-selected-failure))))
+  (doctest-next-failure 1))
+
+(defun doctest-last-failure ()
+  (interactive &quot;&quot;)
+  (if (buffer-live-p doctest-results-buffer)
+      (save-excursion
+        (set-buffer doctest-results-buffer)
+        (let ((old-selected-failure doctest-selected-failure))
+          (setq doctest-selected-failure (point-max))
+          (doctest-fontify-line old-selected-failure))))
+  (doctest-next-failure -1))
+
+(defconst doctest-example-source-re 
+  &quot;^Failed example:\n\\(\n\\|    [^\n]*\n\\)+&quot;)
+(defun hide-example-source ()
+  &quot;Delete the source code listings from the results buffer (since it's
+easy enough to see them in the original buffer)&quot;
+  (save-excursion
+    (set-buffer doctest-results-buffer)
+    (toggle-read-only nil)
+    (beginning-of-buffer)
+    (while (re-search-forward doctest-example-source-re nil t)
+      (replace-match &quot;&quot; nil nil))
+    (toggle-read-only t)))
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Doctest Results Mode (output of doctest-execute-buffer)
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; [XX] Todo:
+;;   - Make it read-only?
+;;   - Hitting enter goes to the corresponding error
+;;   - Clicking goes to corresponding error (not as useful)
+
+
+(defconst doctest-results-divider-re
+  &quot;^\\([*]\\{60,\\}\\)$&quot;)
+
+(defconst doctest-results-loc-re
+  &quot;^File \&quot;\\([^\&quot;]+\\)\&quot;, line \\([0-9]+\\), in \\([^\n]+\\)&quot;)
+
+(defconst doctest-results-header-re
+  &quot;^\\([a-zA-Z0-9 ]+:\\)$&quot;)
+
+(defconst doctest-results-font-lock-keywords
+  `((,doctest-results-divider-re 
+     (0 'doctest-results-divider-face))
+    (,doctest-results-loc-re 
+     (0 'doctest-results-loc-face))
+    (,doctest-results-header-re 
+     (0 'doctest-results-header-face))
+    (doctest-results-selection-matcher 
+     (0 'doctest-results-selection-face t))))
+
+(defun doctest-results-selection-matcher (limit)
+  &quot;Matches from `doctest-selected-failure' to the end of the
+line.  This is used to highlight the currently selected failure.&quot;
+  (when (and doctest-selected-failure
+	     (&lt;= (point) doctest-selected-failure)
+	     (&lt; doctest-selected-failure limit))
+    (goto-char doctest-selected-failure)
+    (search-forward-regexp &quot;[^\n]+&quot; limit)))
+
+;; Register the font-lock keywords (xemacs)
+(put 'doctest-results-mode 'font-lock-defaults 
+     '(doctest-results-font-lock-keywords))
+
+;; Register the font-lock keywords (gnu emacs)
+(defvar font-lock-defaults-alist nil) ; in case we're in xemacs
+(setq font-lock-defaults-alist
+      (append font-lock-defaults-alist
+              `((doctest-results-mode 
+		 doctest-results-font-lock-keywords 
+		 nil nil nil nil))))
+
+;; Define the mode
+(define-derived-mode doctest-results-mode text-mode &quot;Doctest Results&quot;
+  &quot;docstring&quot;
+  ;; Enable font-lock mode.
+  (if (featurep 'font-lock) (font-lock-mode 1))
+  ;; Keep track of which failure is selected
+  (set (make-local-variable 'doctest-selected-failure) nil)
+  ;; Make the buffer read-only.
+  (toggle-read-only t))
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Helper functions
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(defun on-doctest-source-line ()
+  &quot;Return true if the current line is a source line.&quot;
+  (save-excursion
+    (beginning-of-line)
+    (looking-at doctest-prompt-re)))
+
+(defun on-empty-doctest-source-line ()
+  &quot;Return true if the current line contains a bare prompt.&quot;
+  (save-excursion
+    (beginning-of-line)
+    (looking-at (concat doctest-prompt-re &quot;$&quot;))))
+
+(defun on-doctest-output-line ()
+  &quot;Return true if the current line is an output line.&quot;
+  (save-excursion
+    (beginning-of-line)
+    (let ((prompt-or-blankline (concat doctest-prompt-re &quot;\\|&quot; &quot;^[ \t]*\n&quot;)))
+      ;; The line must not be blank or start with a prompt.
+      (when (not (looking-at prompt-or-blankline))
+          ;; The line must follow a line starting with a prompt, with
+          ;; no intervening blank lines.
+          (search-backward-regexp prompt-or-blankline nil t)
+          (looking-at doctest-prompt-re)))))
+
+(defun find-doctest-output-line (&amp;optional limit)
+  &quot;Move forward to the next doctest output line (staying within
+the given bounds).  Return the character position of the doctest
+output line if one was found, and false otherwise.&quot;
+  (let ((found-it nil) ; point where we found an output line
+	(limit (or limit (point-max)))) ; default value for limit
+    (save-excursion
+      ;; Keep moving forward, one line at a time, until we find a
+      ;; doctest output line.
+      (while (and (not found-it) (&lt; (point) limit) (not (eobp)))
+	(if (and (not (eolp)) (on-doctest-output-line))
+	    (setq found-it (point))
+	  (forward-line))))
+    ;; If we found a doctest output line, then go to it.
+    (if found-it (goto-char found-it))))
+
+(defun doctest-version ()
+  &quot;Echo the current version of `doctest-mode' in the minibuffer.&quot;
+  (interactive)
+  (message &quot;Using `doctest-mode' version %s&quot; doctest-version))
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Utility functions
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(defvar doctest-serial-number 0) ;used if broken-temp-names.
+(defun doctest-temp-name ()
+  (if (memq 'broken-temp-names features)
+      (let
+	  ((sn doctest-serial-number)
+	   (pid (and (fboundp 'emacs-pid) (emacs-pid))))
+	(setq doctest-serial-number (1+ doctest-serial-number))
+	(if pid
+	    (format &quot;doctest-%d-%d&quot; sn pid)
+	  (format &quot;doctest-%d&quot; sn)))
+    (make-temp-name &quot;doctest-&quot;)))
+
+(defun column-at-char (pos)
+  &quot;Return the column of the given character position&quot;
+  (save-excursion (goto-char pos) (current-column)))
+
+(defun doctest-looking-back (regexp)
+  &quot;Return True if the text before point matches the given regular
+expression.  Like looking-at except backwards and slower.  (This
+is available as `looking-back' in GNU emacs and
+`looking-at-backwards' in XEmacs, but it's easy enough to define
+from scratch such that it works under both.)&quot;
+  (save-excursion
+    (let ((orig-pos (point)))
+      ;; Search backwards for the regexp.
+      (if (re-search-backward regexp nil t)
+	  ;; Check if it ends at the original point.
+	  (= orig-pos (match-end 0))))))
+
+(defun doctest-fontify-line (charpos)
+  &quot;Run font-lock-fontify-region on the line containing the given
+position.&quot;
+  (if charpos
+      (save-excursion
+        (goto-char charpos)
+        (let ((beg (progn (beginning-of-line) (point)))
+              (end (progn (end-of-line) (point))))
+          (font-lock-fontify-region beg end)))))
+  
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Syntax Table
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; We do *NOT* currently use this, because it applies too
+;; indiscrimanantly.  In particular, we don't want &quot;'&quot; and '&quot;' treated
+;; as quote marks on text lines.  But there's no good way to prevent
+;; it.
+(defvar doctest-syntax-alist nil
+  &quot;Syntax alist used in `doctest-mode' buffers.&quot;)
+(setq doctest-syntax-alist '((?\( . &quot;()&quot;) (?\[ . &quot;(]&quot;) (?\{ . &quot;(}&quot;)
+			     (?\) . &quot;)(&quot;) (?\] . &quot;)[&quot;) (?\} . &quot;){&quot;)
+			     (?\$ . &quot;.&quot; ) (?\% . &quot;.&quot; ) (?\&amp; . &quot;.&quot; )
+			     (?\* . &quot;.&quot; ) (?\+ . &quot;.&quot; ) (?\- . &quot;.&quot; )
+			     (?\/ . &quot;.&quot; ) (?\&lt; . &quot;.&quot; ) (?\= . &quot;.&quot; )
+			     (?\&gt; . &quot;.&quot; ) (?\| . &quot;.&quot; ) (?\_ . &quot;w&quot; )
+			     (?\' . &quot;\&quot;&quot;) (?\&quot; . &quot;\&quot;&quot;) (?\` . &quot;$&quot; )
+			     (?\# . &quot;&lt;&quot; ) (?\n . &quot;&gt;&quot; )))
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Key Bindings
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+(defconst doctest-mode-map 
+  (let ((map (make-keymap)))
+    (define-key map [backspace] 'doctest-electric-backspace)
+    (define-key map [return] 'doctest-newline-and-indent)
+    (define-key map [tab] 'doctest-indent-source-line)
+    (define-key map &quot;:&quot; 'doctest-electric-colon)
+    (define-key map &quot;\C-c\C-v&quot; 'doctest-version)
+    (define-key map &quot;\C-c\C-c&quot; 'doctest-execute-buffer)
+    (define-key map &quot;\C-c\C-n&quot; 'doctest-next-failure)
+    (define-key map &quot;\C-c\C-p&quot; 'doctest-prev-failure)
+    (define-key map &quot;\C-c\C-a&quot; 'doctest-first-failure)
+    (define-key map &quot;\C-c\C-z&quot; 'doctest-last-failure)
+    map) 
+  &quot;Keymap for doctest-mode.&quot;)
+
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+;; Define the mode
+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+;; Register the font-lock keywords (xemacs)
+(put 'doctest-mode 'font-lock-defaults '(doctest-font-lock-keywords))
+
+;; Register the font-lock keywords (gnu emacs)
+(defvar font-lock-defaults-alist nil) ; in case we're in xemacs
+(setq font-lock-defaults-alist
+      (append font-lock-defaults-alist
+              `((doctest-mode doctest-font-lock-keywords nil nil nil nil))))
+
+;; Use doctest mode for files ending in .doctest
+;;;###autoload
+(add-to-list 'auto-mode-alist '(&quot;\\.doctest$&quot; . doctest-mode))
+
+;;;###autoload
+(define-derived-mode doctest-mode text-mode &quot;Doctest&quot;
+  &quot;A major mode for editing text files that contain Python
+doctest examples.  Doctest is a testing framework for Python that
+emulates an interactive session, and checks the result of each
+command.  For more information, see the Python library reference:
+&lt;<A HREF="http://docs.python.org/lib/module-doctest.html">http://docs.python.org/lib/module-doctest.html</A>&gt;
+
+`doctest-mode' defines three kinds of line, each of which is
+treated differently:
+
+  - 'Source lines' are lines consisting of a Python prompt
+    ('&gt;&gt;&gt;' or '...'), followed by source code.  Source lines are
+    colored (similarly to `python-mode') and auto-indented.
+
+  - 'Output lines' are non-blank lines immediately following
+    source lines.  They are colored using several doctest-
+    specific output faces.
+
+  - 'Text lines' are any other lines.  They are not processed in
+    any special way.
+
+\\{doctest-mode-map}
+&quot;
+  ;; Enable auto-fill mode.
+  (auto-fill-mode 1)
+
+  ;; Enable font-lock mode.
+  (if (featurep 'font-lock) (font-lock-mode 1))
+  
+  ;; Register our indentation function.
+  (set (make-local-variable 'indent-line-function) 
+       'doctest-indent-source-line)
+
+  ;; Keep track of our results buffer.
+  (set (make-local-variable 'doctest-results-buffer) nil)
+  )
+
+(provide 'doctest-mode)
+;;; doctest-mode.el ends here

Added: trunk/support/emacs/pycomplete.el
===================================================================
--- trunk/support/emacs/pycomplete.el	2005-11-01 21:07:33 UTC (rev 1)
+++ trunk/support/emacs/pycomplete.el	2005-11-01 23:55:29 UTC (rev 2)
@@ -0,0 +1,36 @@
+;;; Complete symbols at point using Pymacs.
+
+;;; See pycomplete.py for the Python side of things and a short description
+;;; of what to expect.
+
+(require 'pymacs)
+(require 'python-mode)
+
+(pymacs-load &quot;pycomplete&quot;)
+
+(defun py-complete ()
+  (interactive)
+  (let ((pymacs-forget-mutability t)) 
+    (insert (pycomplete-pycomplete (py-symbol-near-point)
+				   (py-find-global-imports)))))
+
+(defun py-find-global-imports ()
+  (save-excursion
+    (let (first-class-or-def imports)
+      (goto-char (point-min))
+      (setq first-class-or-def
+	    (re-search-forward &quot;^ *\\(def\\|class\\) &quot; nil t))
+      (goto-char (point-min))
+      (setq imports nil)
+      (while (re-search-forward
+	      &quot;^\\(import \\|from \\([A-Za-z_][A-Za-z_0-9]*\\) import \\).*&quot;
+	      nil t)
+	(setq imports (append imports
+			      (list (buffer-substring
+				     (match-beginning 0)
+				     (match-end 0))))))
+      imports)))
+
+(define-key py-mode-map &quot;\M-\C-i&quot;  'py-complete)
+
+(provide 'pycomplete)

Added: trunk/support/emacs/pycomplete.py
===================================================================
--- trunk/support/emacs/pycomplete.py	2005-11-01 21:07:33 UTC (rev 1)
+++ trunk/support/emacs/pycomplete.py	2005-11-01 23:55:29 UTC (rev 2)
@@ -0,0 +1,96 @@
+
+&quot;&quot;&quot;
+Python dot expression completion using Pymacs.
+
+This almost certainly needs work, but if you add
+
+    (require 'pycomplete)
+
+to your .xemacs/init.el file (untried w/ GNU Emacs so far) and have Pymacs
+installed, when you hit M-TAB it will try to complete the dot expression
+before point.  For example, given this import at the top of the file:
+
+    import time
+
+typing &quot;time.cl&quot; then hitting M-TAB should complete &quot;time.clock&quot;.
+
+This is unlikely to be done the way Emacs completion ought to be done, but
+it's a start.  Perhaps someone with more Emacs mojo can take this stuff and
+do it right.
+
+See pycomplete.el for the Emacs Lisp side of things.
+&quot;&quot;&quot;
+
+import sys
+import os.path
+
+try:
+    x = set
+except NameError:
+    from sets import Set as set
+else:
+    del x
+
+def get_all_completions(s, imports=None):
+    &quot;&quot;&quot;Return contextual completion of s (string of &gt;= zero chars).
+
+    If given, imports is a list of import statements to be executed first.
+    &quot;&quot;&quot;
+    locald = {}
+    if imports is not None:
+        for stmt in imports:
+            try:
+                exec stmt in globals(), locald
+            except TypeError:
+                raise TypeError, &quot;invalid type: %s&quot; % stmt
+
+    dots = s.split(&quot;.&quot;)
+    if not s or len(dots) == 1:
+        keys = set()
+        keys.update(locald.keys())
+        keys.update(globals().keys())
+        import __builtin__
+        keys.update(dir(__builtin__))
+        keys = list(keys)
+        keys.sort()
+        if s:
+            return [k for k in keys if k.startswith(s)]
+        else:
+            return keys
+
+    sym = None
+    for i in range(1, len(dots)):
+        s = &quot;.&quot;.join(dots[:i])
+        try:
+            sym = eval(s, globals(), locald)
+        except NameError:
+            try:
+                sym = __import__(s, globals(), locald, [])
+            except ImportError:
+                return []
+    if sym is not None:
+        s = dots[-1]
+        return [k for k in dir(sym) if k.startswith(s)]
+
+def pycomplete(s, imports=None):
+    completions = get_all_completions(s, imports)
+    dots = s.split(&quot;.&quot;)
+    return os.path.commonprefix([k[len(dots[-1]):] for k in completions])
+
+if __name__ == &quot;__main__&quot;:
+    print &quot;&lt;empty&gt; -&gt;&quot;, pycomplete(&quot;&quot;)
+    print &quot;sys.get -&gt;&quot;, pycomplete(&quot;sys.get&quot;)
+    print &quot;sy -&gt;&quot;, pycomplete(&quot;sy&quot;)
+    print &quot;sy (sys in context) -&gt;&quot;, pycomplete(&quot;sy&quot;, imports=[&quot;import sys&quot;])
+    print &quot;foo. -&gt;&quot;, pycomplete(&quot;foo.&quot;)
+    print &quot;Enc (email * imported) -&gt;&quot;,
+    print pycomplete(&quot;Enc&quot;, imports=[&quot;from email import *&quot;])
+    print &quot;E (email * imported) -&gt;&quot;,
+    print pycomplete(&quot;E&quot;, imports=[&quot;from email import *&quot;])
+
+    print &quot;Enc -&gt;&quot;, pycomplete(&quot;Enc&quot;)
+    print &quot;E -&gt;&quot;, pycomplete(&quot;E&quot;)
+
+# Local Variables :
+# pymacs-auto-reload : t
+# End :

Added: trunk/support/emacs/python-mode.el
===================================================================
--- trunk/support/emacs/python-mode.el	2005-11-01 21:07:33 UTC (rev 1)
+++ trunk/support/emacs/python-mode.el	2005-11-01 23:55:29 UTC (rev 2)
@@ -0,0 +1,3851 @@
+;;; python-mode.el --- Major mode for editing Python programs
+
+;; Copyright (C) 1992,1993,1994  Tim Peters
+
+;; Author: 2003-2004 <A HREF="http://sf.net/projects/python-mode">http://sf.net/projects/python-mode</A>
+;;         1995-2002 Barry A. Warsaw
+;;         1992-1994 Tim Peters
+;; Maintainer: <A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">python-mode at python.org</A>
+;; Created:    Feb 1992
+;; Keywords:   python languages oop
+
+(defconst py-version &quot;$Revision: 4.63 $&quot;
+  &quot;`python-mode' version number.&quot;)
+
+;; This software is provided as-is, without express or implied
+;; warranty.  Permission to use, copy, modify, distribute or sell this
+;; software, without fee, for any purpose and by any individual or
+;; organization, is hereby granted, provided that the above copyright
+;; notice and this paragraph appear in all copies.
+
+;;; Commentary:
+
+;; This is a major mode for editing Python programs.  It was developed by Tim
+;; Peters after an original idea by Michael A. Guravage.  Tim subsequently
+;; left the net and in 1995, Barry Warsaw inherited the mode.  Tim's now back
+;; but disavows all responsibility for the mode.  In fact, we suspect he
+;; doesn't even use Emacs any more.  In 2003, python-mode.el was moved to its
+;; own SourceForge project apart from the Python project, and now is
+;; maintained by the volunteers at the <A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">python-mode at python.org</A> mailing list.
+
+;; pdbtrack support contributed by Ken Manheimer, April 2001.  Skip Montanaro
+;; has also contributed significantly to python-mode's development.
+
+;; Please use the SourceForge Python project to submit bugs or
+;; patches:
+;;
+;;     <A HREF="http://sourceforge.net/projects/python">http://sourceforge.net/projects/python</A>
+
+;; INSTALLATION:
+
+;; To install, just drop this file into a directory on your load-path and
+;; byte-compile it.  To set up Emacs to automatically edit files ending in
+;; &quot;.py&quot; using python-mode add the following to your ~/.emacs file (GNU
+;; Emacs) or ~/.xemacs/init.el file (XEmacs):
+;;    (setq auto-mode-alist (cons '(&quot;\\.py$&quot; . python-mode) auto-mode-alist))
+;;    (setq interpreter-mode-alist (cons '(&quot;python&quot; . python-mode)
+;;                                       interpreter-mode-alist))
+;;    (autoload 'python-mode &quot;python-mode&quot; &quot;Python editing mode.&quot; t)
+;;
+;; In XEmacs syntax highlighting should be enabled automatically.  In GNU
+;; Emacs you may have to add these lines to your ~/.emacs file:
+;;    (global-font-lock-mode t)
+;;    (setq font-lock-maximum-decoration t)
+
+;; FOR MORE INFORMATION:
+
+;; There is some information on python-mode.el at
+
+;;     <A HREF="http://www.python.org/emacs/python-mode/">http://www.python.org/emacs/python-mode/</A>
+;;
+;; It does contain links to other packages that you might find useful,
+;; such as pdb interfaces, OO-Browser links, etc.
+
+;; BUG REPORTING:
+
+;; As mentioned above, please use the SourceForge Python project for
+;; submitting bug reports or patches.  The old recommendation, to use
+;; C-c C-b will still work, but those reports have a higher chance of
+;; getting buried in my mailbox.  Please include a complete, but
+;; concise code sample and a recipe for reproducing the bug.  Send
+;; suggestions and other comments to <A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">python-mode at python.org.</A>
+
+;; When in a Python mode buffer, do a C-h m for more help.  It's
+;; doubtful that a texinfo manual would be very useful, but if you
+;; want to contribute one, I'll certainly accept it!
+
+;;; Code:
+
+(require 'comint)
+(require 'custom)
+(require 'cl)
+(require 'compile)
+
+
+;; user definable variables
+;; vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
+
+(defgroup python nil
+  &quot;Support for the Python programming language, &lt;<A HREF="http://www.python.org/">http://www.python.org/</A>&gt;&quot;
+  :group 'languages
+  :prefix &quot;py-&quot;)
+
+(defcustom py-python-command &quot;python&quot;
+  &quot;*Shell command used to start Python interpreter.&quot;
+  :type 'string
+  :group 'python)
+
+(defcustom py-jpython-command &quot;jpython&quot;
+  &quot;*Shell command used to start the JPython interpreter.&quot;
+  :type 'string
+  :group 'python
+  :tag &quot;JPython Command&quot;)
+
+(defcustom py-default-interpreter 'cpython
+  &quot;*Which Python interpreter is used by default.
+The value for this variable can be either `cpython' or `jpython'.
+
+When the value is `cpython', the variables `py-python-command' and
+`py-python-command-args' are consulted to determine the interpreter
+and arguments to use.
+
+When the value is `jpython', the variables `py-jpython-command' and
+`py-jpython-command-args' are consulted to determine the interpreter
+and arguments to use.
+
+Note that this variable is consulted only the first time that a Python
+mode buffer is visited during an Emacs session.  After that, use
+\\[py-toggle-shells] to change the interpreter shell.&quot;
+  :type '(choice (const :tag &quot;Python (a.k.a. CPython)&quot; cpython)
+		 (const :tag &quot;JPython&quot; jpython))
+  :group 'python)
+
+(defcustom py-python-command-args '(&quot;-i&quot;)
+  &quot;*List of string arguments to be used when starting a Python shell.&quot;
+  :type '(repeat string)
+  :group 'python)
+
+(defcustom py-jpython-command-args '(&quot;-i&quot;)
+  &quot;*List of string arguments to be used when starting a JPython shell.&quot;
+  :type '(repeat string)
+  :group 'python
+  :tag &quot;JPython Command Args&quot;)
+
+(defcustom py-indent-offset 4
+  &quot;*Amount of offset per level of indentation.
+`\\[py-guess-indent-offset]' can usually guess a good value when
+you're editing someone else's Python code.&quot;
+  :type 'integer
+  :group 'python)
+
+(defcustom py-continuation-offset 4
+  &quot;*Additional amount of offset to give for some continuation lines.
+Continuation lines are those that immediately follow a backslash
+terminated line.  Only those continuation lines for a block opening
+statement are given this extra offset.&quot;
+  :type 'integer
+  :group 'python)
+
+(defcustom py-smart-indentation t
+  &quot;*Should `python-mode' try to automagically set some indentation variables?
+When this variable is non-nil, two things happen when a buffer is set
+to `python-mode':
+
+    1. `py-indent-offset' is guessed from existing code in the buffer.
+       Only guessed values between 2 and 8 are considered.  If a valid
+       guess can't be made (perhaps because you are visiting a new
+       file), then the value in `py-indent-offset' is used.
+
+    2. `indent-tabs-mode' is turned off if `py-indent-offset' does not
+       equal `tab-width' (`indent-tabs-mode' is never turned on by
+       Python mode).  This means that for newly written code, tabs are
+       only inserted in indentation if one tab is one indentation
+       level, otherwise only spaces are used.
+
+Note that both these settings occur *after* `python-mode-hook' is run,
+so if you want to defeat the automagic configuration, you must also
+set `py-smart-indentation' to nil in your `python-mode-hook'.&quot;
+  :type 'boolean
+  :group 'python)
+
+(defcustom py-align-multiline-strings-p t
+  &quot;*Flag describing how multi-line triple quoted strings are aligned.
+When this flag is non-nil, continuation lines are lined up under the
+preceding line's indentation.  When this flag is nil, continuation
+lines are aligned to column zero.&quot;
+  :type '(choice (const :tag &quot;Align under preceding line&quot; t)
+		 (const :tag &quot;Align to column zero&quot; nil))
+  :group 'python)
+
+(defcustom py-block-comment-prefix &quot;##&quot;
+  &quot;*String used by \\[comment-region] to comment out a block of code.
+This should follow the convention for non-indenting comment lines so
+that the indentation commands won't get confused (i.e., the string
+should be of the form `#x...' where `x' is not a blank or a tab, and
+`...' is arbitrary).  However, this string should not end in whitespace.&quot;
+  :type 'string
+  :group 'python)
+
+(defcustom py-honor-comment-indentation t
+  &quot;*Controls how comment lines influence subsequent indentation.
+
+When nil, all comment lines are skipped for indentation purposes, and
+if possible, a faster algorithm is used (i.e. X/Emacs 19 and beyond).
+
+When t, lines that begin with a single `#' are a hint to subsequent
+line indentation.  If the previous line is such a comment line (as
+opposed to one that starts with `py-block-comment-prefix'), then its
+indentation is used as a hint for this line's indentation.  Lines that
+begin with `py-block-comment-prefix' are ignored for indentation
+purposes.
+
+When not nil or t, comment lines that begin with a single `#' are used
+as indentation hints, unless the comment character is in column zero.&quot;
+  :type '(choice
+	  (const :tag &quot;Skip all comment lines (fast)&quot; nil)
+	  (const :tag &quot;Single # `sets' indentation for next line&quot; t)
+	  (const :tag &quot;Single # `sets' indentation except at column zero&quot;
+		 other)
+	  )
+  :group 'python)
+
+(defcustom py-temp-directory
+  (let ((ok '(lambda (x)
+	       (and x
+		    (setq x (expand-file-name x)) ; always true
+		    (file-directory-p x)
+		    (file-writable-p x)
+		    x))))
+    (or (funcall ok (getenv &quot;TMPDIR&quot;))
+	(funcall ok &quot;/usr/tmp&quot;)
+	(funcall ok &quot;/tmp&quot;)
+	(funcall ok &quot;/var/tmp&quot;)
+	(funcall ok  &quot;.&quot;)
+	(error
+	 &quot;Couldn't find a usable temp directory -- set `py-temp-directory'&quot;)))
+  &quot;*Directory used for temporary files created by a *Python* process.
+By default, the first directory from this list that exists and that you
+can write into: the value (if any) of the environment variable TMPDIR,
+/usr/tmp, /tmp, /var/tmp, or the current directory.&quot;
+  :type 'string
+  :group 'python)
+
+(defcustom py-beep-if-tab-change t
+  &quot;*Ring the bell if `tab-width' is changed.
+If a comment of the form
+
+  \t# vi:set tabsize=&lt;number&gt;:
+
+is found before the first code line when the file is entered, and the
+current value of (the general Emacs variable) `tab-width' does not
+equal &lt;number&gt;, `tab-width' is set to &lt;number&gt;, a message saying so is
+displayed in the echo area, and if `py-beep-if-tab-change' is non-nil
+the Emacs bell is also rung as a warning.&quot;
+  :type 'boolean
+  :group 'python)
+
+(defcustom py-jump-on-exception t
+  &quot;*Jump to innermost exception frame in *Python Output* buffer.
+When this variable is non-nil and an exception occurs when running
+Python code synchronously in a subprocess, jump immediately to the
+source code of the innermost traceback frame.&quot;
+  :type 'boolean
+  :group 'python)
+
+(defcustom py-ask-about-save t
+  &quot;If not nil, ask about which buffers to save before executing some code.
+Otherwise, all modified buffers are saved without asking.&quot;
+  :type 'boolean
+  :group 'python)
+
+(defcustom py-backspace-function 'backward-delete-char-untabify
+  &quot;*Function called by `py-electric-backspace' when deleting backwards.&quot;
+  :type 'function
+  :group 'python)
+
+(defcustom py-delete-function 'delete-char
+  &quot;*Function called by `py-electric-delete' when deleting forwards.&quot;
+  :type 'function
+  :group 'python)
+
+(defcustom py-imenu-show-method-args-p nil 
+  &quot;*Controls echoing of arguments of functions &amp; methods in the Imenu buffer.
+When non-nil, arguments are printed.&quot;
+  :type 'boolean
+  :group 'python)
+(make-variable-buffer-local 'py-indent-offset)
+
+(defcustom py-pdbtrack-do-tracking-p t
+  &quot;*Controls whether the pdbtrack feature is enabled or not.
+When non-nil, pdbtrack is enabled in all comint-based buffers,
+e.g. shell buffers and the *Python* buffer.  When using pdb to debug a
+Python program, pdbtrack notices the pdb prompt and displays the
+source file and line that the program is stopped at, much the same way
+as gud-mode does for debugging C programs with gdb.&quot;
+  :type 'boolean
+  :group 'python)
+(make-variable-buffer-local 'py-pdbtrack-do-tracking-p)
+
+(defcustom py-pdbtrack-minor-mode-string &quot; PDB&quot;
+  &quot;*String to use in the minor mode list when pdbtrack is enabled.&quot;
+  :type 'string
+  :group 'python)
+
+(defcustom py-import-check-point-max
+  20000
+  &quot;Maximum number of characters to search for a Java-ish import statement.
+When `python-mode' tries to calculate the shell to use (either a
+CPython or a JPython shell), it looks at the so-called `shebang' line
+-- i.e. #! line.  If that's not available, it looks at some of the
+file heading imports to see if they look Java-like.&quot;
+  :type 'integer
+  :group 'python
+  )
+
+(defcustom py-jpython-packages
+  '(&quot;java&quot; &quot;javax&quot; &quot;org&quot; &quot;com&quot;)
+  &quot;Imported packages that imply `jpython-mode'.&quot;
+  :type '(repeat string)
+  :group 'python)
+  
+;; Not customizable
+(defvar py-master-file nil
+  &quot;If non-nil, execute the named file instead of the buffer's file.
+The intent is to allow you to set this variable in the file's local
+variable section, e.g.:
+
+    # Local Variables:
+    # py-master-file: \&quot;master.py\&quot;
+    # End:
+
+so that typing \\[py-execute-buffer] in that buffer executes the named
+master file instead of the buffer's file.  If the file name has a
+relative path, the value of variable `default-directory' for the
+buffer is prepended to come up with a file name.&quot;)
+(make-variable-buffer-local 'py-master-file)
+
+(defcustom py-pychecker-command &quot;pychecker&quot;
+  &quot;*Shell command used to run Pychecker.&quot;
+  :type 'string
+  :group 'python
+  :tag &quot;Pychecker Command&quot;)
+
+(defcustom py-pychecker-command-args '(&quot;--stdlib&quot;)
+  &quot;*List of string arguments to be passed to pychecker.&quot;
+  :type '(repeat string)
+  :group 'python
+  :tag &quot;Pychecker Command Args&quot;)
+
+(defvar py-shell-alist
+  '((&quot;jpython&quot; . 'jpython)
+    (&quot;jython&quot; . 'jpython)
+    (&quot;python&quot; . 'cpython))
+  &quot;*Alist of interpreters and python shells. Used by `py-choose-shell'
+to select the appropriate python interpreter mode for a file.&quot;)
+
+
+;; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+;; NO USER DEFINABLE VARIABLES BEYOND THIS POINT
+
+(defconst py-emacs-features
+  (let (features)
+   features)
+  &quot;A list of features extant in the Emacs you are using.
+There are many flavors of Emacs out there, with different levels of
+support for features needed by `python-mode'.&quot;)
+
+;; Face for None, True, False, self, and Ellipsis
+(defvar py-pseudo-keyword-face 'py-pseudo-keyword-face
+  &quot;Face for pseudo keywords in Python mode, like self, True, False, Ellipsis.&quot;)
+(make-face 'py-pseudo-keyword-face)
+
+;; PEP 318 decorators
+(defvar py-decorators-face 'py-decorators-face
+  &quot;Face method decorators.&quot;)
+(make-face 'py-decorators-face)
+
+;; Face for builtins
+(defvar py-builtins-face 'py-builtins-face
+  &quot;Face for builtins like TypeError, object, open, and exec.&quot;)
+(make-face 'py-builtins-face)
+
+(defun py-font-lock-mode-hook ()
+  (or (face-differs-from-default-p 'py-pseudo-keyword-face)
+      (copy-face 'font-lock-keyword-face 'py-pseudo-keyword-face))
+  (or (face-differs-from-default-p 'py-builtins-face)
+      (copy-face 'font-lock-keyword-face 'py-builtins-face))
+  (or (face-differs-from-default-p 'py-decorators-face)
+      (copy-face 'py-pseudo-keyword-face 'py-decorators-face))
+  )
+(add-hook 'font-lock-mode-hook 'py-font-lock-mode-hook)
+
+(defvar python-font-lock-keywords
+  (let ((kw1 (mapconcat 'identity
+			'(&quot;and&quot;      &quot;assert&quot;   &quot;break&quot;   &quot;class&quot;
+			  &quot;continue&quot; &quot;def&quot;      &quot;del&quot;     &quot;elif&quot;
+			  &quot;else&quot;     &quot;except&quot;   &quot;exec&quot;    &quot;for&quot;
+			  &quot;from&quot;     &quot;global&quot;   &quot;if&quot;      &quot;import&quot;
+			  &quot;in&quot;       &quot;is&quot;       &quot;lambda&quot;  &quot;not&quot;
+			  &quot;or&quot;       &quot;pass&quot;     &quot;print&quot;   &quot;raise&quot;
+			  &quot;return&quot;   &quot;while&quot;    &quot;yield&quot;
+			  )
+			&quot;\\|&quot;))
+	(kw2 (mapconcat 'identity
+			'(&quot;else:&quot; &quot;except:&quot; &quot;finally:&quot; &quot;try:&quot;)
+			&quot;\\|&quot;))
+	(kw3 (mapconcat 'identity
+			;; Don't include True, False, None, or
+			;; Ellipsis in this list, since they are
+			;; already defined as pseudo keywords.
+			'(&quot;__debug__&quot;
+			  &quot;__import__&quot; &quot;__name__&quot; &quot;abs&quot; &quot;apply&quot; &quot;basestring&quot;
+			  &quot;bool&quot; &quot;buffer&quot; &quot;callable&quot; &quot;chr&quot; &quot;classmethod&quot;
+			  &quot;cmp&quot; &quot;coerce&quot; &quot;compile&quot; &quot;complex&quot; &quot;copyright&quot;
+			  &quot;delattr&quot; &quot;dict&quot; &quot;dir&quot; &quot;divmod&quot;
+			  &quot;enumerate&quot; &quot;eval&quot; &quot;execfile&quot; &quot;exit&quot; &quot;file&quot;
+			  &quot;filter&quot; &quot;float&quot; &quot;getattr&quot; &quot;globals&quot; &quot;hasattr&quot;
+			  &quot;hash&quot; &quot;hex&quot; &quot;id&quot; &quot;input&quot; &quot;int&quot; &quot;intern&quot;
+			  &quot;isinstance&quot; &quot;issubclass&quot; &quot;iter&quot; &quot;len&quot; &quot;license&quot;
+			  &quot;list&quot; &quot;locals&quot; &quot;long&quot; &quot;map&quot; &quot;max&quot; &quot;min&quot; &quot;object&quot;
+			  &quot;oct&quot; &quot;open&quot; &quot;ord&quot; &quot;pow&quot; &quot;property&quot; &quot;range&quot;
+			  &quot;raw_input&quot; &quot;reduce&quot; &quot;reload&quot; &quot;repr&quot; &quot;round&quot;
+			  &quot;setattr&quot; &quot;slice&quot; &quot;staticmethod&quot; &quot;str&quot; &quot;sum&quot;
+			  &quot;super&quot; &quot;tuple&quot; &quot;type&quot; &quot;unichr&quot; &quot;unicode&quot; &quot;vars&quot;
+			  &quot;xrange&quot; &quot;zip&quot;)
+			&quot;\\|&quot;))
+	(kw4 (mapconcat 'identity
+			;; Exceptions and warnings
+			'(&quot;ArithmeticError&quot; &quot;AssertionError&quot;
+			  &quot;AttributeError&quot; &quot;DeprecationWarning&quot; &quot;EOFError&quot;
+			  &quot;EnvironmentError&quot; &quot;Exception&quot;
+			  &quot;FloatingPointError&quot; &quot;FutureWarning&quot; &quot;IOError&quot;
+			  &quot;ImportError&quot; &quot;IndentationError&quot; &quot;IndexError&quot;
+			  &quot;KeyError&quot; &quot;KeyboardInterrupt&quot; &quot;LookupError&quot;
+			  &quot;MemoryError&quot; &quot;NameError&quot; &quot;NotImplemented&quot;
+			  &quot;NotImplementedError&quot; &quot;OSError&quot; &quot;OverflowError&quot;
+			  &quot;OverflowWarning&quot; &quot;PendingDeprecationWarning&quot;
+			  &quot;ReferenceError&quot; &quot;RuntimeError&quot; &quot;RuntimeWarning&quot;
+			  &quot;StandardError&quot; &quot;StopIteration&quot; &quot;SyntaxError&quot;
+			  &quot;SyntaxWarning&quot; &quot;SystemError&quot; &quot;SystemExit&quot;
+			  &quot;TabError&quot; &quot;TypeError&quot; &quot;UnboundLocalError&quot;
+			  &quot;UnicodeDecodeError&quot; &quot;UnicodeEncodeError&quot;
+			  &quot;UnicodeError&quot; &quot;UnicodeTranslateError&quot;
+			  &quot;UserWarning&quot; &quot;ValueError&quot; &quot;Warning&quot;
+			  &quot;ZeroDivisionError&quot;)
+			&quot;\\|&quot;))
+	)
+    (list
+     '(&quot;^[ \t]*\\(@.+\\)&quot; 1 'py-decorators-face)
+     ;; keywords
+     (cons (concat &quot;\\b\\(&quot; kw1 &quot;\\)\\b[ \n\t(]&quot;) 1)
+     ;; builtins when they don't appear as object attributes
+     (list (concat &quot;\\([^. \t]\\|^\\)[ \t]*\\b\\(&quot; kw3 &quot;\\)\\b[ \n\t(]&quot;) 2
+	   'py-builtins-face)
+     ;; block introducing keywords with immediately following colons.
+     ;; Yes &quot;except&quot; is in both lists.
+     (cons (concat &quot;\\b\\(&quot; kw2 &quot;\\)[ \n\t(]&quot;) 1)
+     ;; Exceptions
+     (list (concat &quot;\\b\\(&quot; kw4 &quot;\\)[ \n\t:,(]&quot;) 1 'py-builtins-face)
+     ;; `as' but only in &quot;import foo as bar&quot;
+     '(&quot;[ \t]*\\(\\bfrom\\b.*\\)?\\bimport\\b.*\\b\\(as\\)\\b&quot; . 2)
+     ;; classes
+     '(&quot;\\bclass[ \t]+\\([a-zA-Z_]+[a-zA-Z0-9_]*\\)&quot; 1 font-lock-type-face)
+     ;; functions
+     '(&quot;\\bdef[ \t]+\\([a-zA-Z_]+[a-zA-Z0-9_]*\\)&quot;
+       1 font-lock-function-name-face)
+     ;; pseudo-keywords
+     '(&quot;\\b\\(self\\|None\\|True\\|False\\|Ellipsis\\)\\b&quot;
+       1 py-pseudo-keyword-face)
+     ))
+  &quot;Additional expressions to highlight in Python mode.&quot;)
+(put 'python-mode 'font-lock-defaults '(python-font-lock-keywords))
+
+;; have to bind py-file-queue before installing the kill-emacs-hook
+(defvar py-file-queue nil
+  &quot;Queue of Python temp files awaiting execution.
+Currently-active file is at the head of the list.&quot;)
+
+(defvar py-pdbtrack-is-tracking-p nil)
+
+(defvar py-pychecker-history nil)
+
+
+
+;; Constants
+
+(defconst py-stringlit-re
+  (concat
+   ;; These fail if backslash-quote ends the string (not worth
+   ;; fixing?).  They precede the short versions so that the first two
+   ;; quotes don't look like an empty short string.
+   ;;
+   ;; (maybe raw), long single quoted triple quoted strings (SQTQ),
+   ;; with potential embedded single quotes
+   &quot;[rR]?'''[^']*\\(\\('[^']\\|''[^']\\)[^']*\\)*'''&quot;
+   &quot;\\|&quot;
+   ;; (maybe raw), long double quoted triple quoted strings (DQTQ),
+   ;; with potential embedded double quotes
+   &quot;[rR]?\&quot;\&quot;\&quot;[^\&quot;]*\\(\\(\&quot;[^\&quot;]\\|\&quot;\&quot;[^\&quot;]\\)[^\&quot;]*\\)*\&quot;\&quot;\&quot;&quot;
+   &quot;\\|&quot;
+   &quot;[rR]?'\\([^'\n\\]\\|\\\\.\\)*'&quot;	; single-quoted
+   &quot;\\|&quot;				; or
+   &quot;[rR]?\&quot;\\([^\&quot;\n\\]\\|\\\\.\\)*\&quot;&quot;	; double-quoted
+   )
+  &quot;Regular expression matching a Python string literal.&quot;)
+
+(defconst py-continued-re
+  ;; This is tricky because a trailing backslash does not mean
+  ;; continuation if it's in a comment
+  (concat
+   &quot;\\(&quot; &quot;[^#'\&quot;\n\\]&quot; &quot;\\|&quot; py-stringlit-re &quot;\\)*&quot;
+   &quot;\\\\$&quot;)
+  &quot;Regular expression matching Python backslash continuation lines.&quot;)
+  
+(defconst py-blank-or-comment-re &quot;[ \t]*\\($\\|#\\)&quot;
+  &quot;Regular expression matching a blank or comment line.&quot;)
+
+(defconst py-outdent-re
+  (concat &quot;\\(&quot; (mapconcat 'identity
+			   '(&quot;else:&quot;
+			     &quot;except\\(\\s +.*\\)?:&quot;
+			     &quot;finally:&quot;
+			     &quot;elif\\s +.*:&quot;)
+			   &quot;\\|&quot;)
+	  &quot;\\)&quot;)
+  &quot;Regular expression matching statements to be dedented one level.&quot;)
+  
+(defconst py-block-closing-keywords-re
+  &quot;\\(return\\|raise\\|break\\|continue\\|pass\\)&quot;
+  &quot;Regular expression matching keywords which typically close a block.&quot;)
+
+(defconst py-no-outdent-re
+  (concat
+   &quot;\\(&quot;
+   (mapconcat 'identity
+	      (list &quot;try:&quot;
+		    &quot;except\\(\\s +.*\\)?:&quot;
+		    &quot;while\\s +.*:&quot;
+		    &quot;for\\s +.*:&quot;
+		    &quot;if\\s +.*:&quot;
+		    &quot;elif\\s +.*:&quot;
+		    (concat py-block-closing-keywords-re &quot;[ \t\n]&quot;)
+		    )
+	      &quot;\\|&quot;)
+	  &quot;\\)&quot;)
+  &quot;Regular expression matching lines not to dedent after.&quot;)
+
+(defconst py-traceback-line-re
+  &quot;[ \t]+File \&quot;\\([^\&quot;]+\\)\&quot;, line \\([0-9]+\\)&quot;
+  &quot;Regular expression that describes tracebacks.&quot;)
+
+;; pdbtrack constants
+(defconst py-pdbtrack-stack-entry-regexp
+;  &quot;^&gt; \\([^(]+\\)(\\([0-9]+\\))\\([?a-zA-Z0-9_]+\\)()&quot;
+  &quot;^&gt; \\(.*\\)(\\([0-9]+\\))\\([?a-zA-Z0-9_]+\\)()&quot;
+  &quot;Regular expression pdbtrack uses to find a stack trace entry.&quot;)
+
+(defconst py-pdbtrack-input-prompt &quot;\n[(&lt;]*[Pp]db[&gt;)]+ &quot;
+  &quot;Regular expression pdbtrack uses to recognize a pdb prompt.&quot;)
+
+(defconst py-pdbtrack-track-range 10000
+  &quot;Max number of characters from end of buffer to search for stack entry.&quot;)
+
+
+
+;; Major mode boilerplate
+
+;; define a mode-specific abbrev table for those who use such things
+(defvar python-mode-abbrev-table nil
+  &quot;Abbrev table in use in `python-mode' buffers.&quot;)
+(define-abbrev-table 'python-mode-abbrev-table nil)
+
+(defvar python-mode-hook nil
+  &quot;*Hook called by `python-mode'.&quot;)
+
+(defvar jpython-mode-hook nil
+  &quot;*Hook called by `jpython-mode'. `jpython-mode' also calls
+`python-mode-hook'.&quot;)
+
+(defvar py-shell-hook nil
+  &quot;*Hook called by `py-shell'.&quot;)
+
+;; In previous version of python-mode.el, the hook was incorrectly
+;; called py-mode-hook, and was not defvar'd.  Deprecate its use.
+(and (fboundp 'make-obsolete-variable)
+     (make-obsolete-variable 'py-mode-hook 'python-mode-hook))
+
+(defvar py-mode-map ()
+  &quot;Keymap used in `python-mode' buffers.&quot;)
+(if py-mode-map
+    nil
+  (setq py-mode-map (make-sparse-keymap))
+  ;; electric keys
+  (define-key py-mode-map &quot;:&quot; 'py-electric-colon)
+  ;; indentation level modifiers
+  (define-key py-mode-map &quot;\C-c\C-l&quot;  'py-shift-region-left)
+  (define-key py-mode-map &quot;\C-c\C-r&quot;  'py-shift-region-right)
+  (define-key py-mode-map &quot;\C-c&lt;&quot;     'py-shift-region-left)
+  (define-key py-mode-map &quot;\C-c&gt;&quot;     'py-shift-region-right)
+  ;; subprocess commands
+  (define-key py-mode-map &quot;\C-c\C-c&quot;  'py-execute-buffer)
+  (define-key py-mode-map &quot;\C-c\C-m&quot;  'py-execute-import-or-reload)
+  (define-key py-mode-map &quot;\C-c\C-s&quot;  'py-execute-string)
+  (define-key py-mode-map &quot;\C-c|&quot;     'py-execute-region)
+  (define-key py-mode-map &quot;\e\C-x&quot;    'py-execute-def-or-class)
+  (define-key py-mode-map &quot;\C-c!&quot;     'py-shell)
+  (define-key py-mode-map &quot;\C-c\C-t&quot;  'py-toggle-shells)
+  ;; Caution!  Enter here at your own risk.  We are trying to support
+  ;; several behaviors and it gets disgusting. :-( This logic ripped
+  ;; largely from CC Mode.
+  ;;
+  ;; In XEmacs 19, Emacs 19, and Emacs 20, we use this to bind
+  ;; backwards deletion behavior to DEL, which both Delete and
+  ;; Backspace get translated to.  There's no way to separate this
+  ;; behavior in a clean way, so deal with it!  Besides, it's been
+  ;; this way since the dawn of time.
+  (if (not (boundp 'delete-key-deletes-forward))
+      (define-key py-mode-map &quot;\177&quot; 'py-electric-backspace)
+    ;; However, XEmacs 20 actually achieved enlightenment.  It is
+    ;; possible to sanely define both backward and forward deletion
+    ;; behavior under X separately (TTYs are forever beyond hope, but
+    ;; who cares?  XEmacs 20 does the right thing with these too).
+    (define-key py-mode-map [delete]    'py-electric-delete)
+    (define-key py-mode-map [backspace] 'py-electric-backspace))
+  ;; Separate M-BS from C-M-h.  The former should remain
+  ;; backward-kill-word.
+  (define-key py-mode-map [(control meta h)] 'py-mark-def-or-class)
+  (define-key py-mode-map &quot;\C-c\C-k&quot;  'py-mark-block)
+  ;; Miscellaneous
+  (define-key py-mode-map &quot;\C-c:&quot;     'py-guess-indent-offset)
+  (define-key py-mode-map &quot;\C-c\t&quot;    'py-indent-region)
+  (define-key py-mode-map &quot;\C-c\C-d&quot;  'py-pdbtrack-toggle-stack-tracking)
+  (define-key py-mode-map &quot;\C-c\C-n&quot;  'py-next-statement)
+  (define-key py-mode-map &quot;\C-c\C-p&quot;  'py-previous-statement)
+  (define-key py-mode-map &quot;\C-c\C-u&quot;  'py-goto-block-up)
+  (define-key py-mode-map &quot;\C-c#&quot;     'py-comment-region)
+  (define-key py-mode-map &quot;\C-c?&quot;     'py-describe-mode)
+  (define-key py-mode-map &quot;\C-c\C-h&quot;  'py-help-at-point)
+  (define-key py-mode-map &quot;\e\C-a&quot;    'py-beginning-of-def-or-class)
+  (define-key py-mode-map &quot;\e\C-e&quot;    'py-end-of-def-or-class)
+  (define-key py-mode-map &quot;\C-c-&quot;     'py-up-exception)
+  (define-key py-mode-map &quot;\C-c=&quot;     'py-down-exception)
+  ;; stuff that is `standard' but doesn't interface well with
+  ;; python-mode, which forces us to rebind to special commands
+  (define-key py-mode-map &quot;\C-xnd&quot;    'py-narrow-to-defun)
+  ;; information
+  (define-key py-mode-map &quot;\C-c\C-b&quot; 'py-submit-bug-report)
+  (define-key py-mode-map &quot;\C-c\C-v&quot; 'py-version)
+  (define-key py-mode-map &quot;\C-c\C-w&quot; 'py-pychecker-run)
+  ;; shadow global bindings for newline-and-indent w/ the py- version.
+  ;; BAW - this is extremely bad form, but I'm not going to change it
+  ;; for now.
+  (mapcar #'(lambda (key)
+	      (define-key py-mode-map key 'py-newline-and-indent))
+	  (where-is-internal 'newline-and-indent))
+  ;; Force RET to be py-newline-and-indent even if it didn't get
+  ;; mapped by the above code.  motivation: Emacs' default binding for
+  ;; RET is `newline' and C-j is `newline-and-indent'.  Most Pythoneers
+  ;; expect RET to do a `py-newline-and-indent' and any Emacsers who
+  ;; dislike this are probably knowledgeable enough to do a rebind.
+  ;; However, we do *not* change C-j since many Emacsers have already
+  ;; swapped RET and C-j and they don't want C-j bound to `newline' to 
+  ;; change.
+  (define-key py-mode-map &quot;\C-m&quot; 'py-newline-and-indent)
+  )
+
+(defvar py-mode-output-map nil
+  &quot;Keymap used in *Python Output* buffers.&quot;)
+(if py-mode-output-map
+    nil
+  (setq py-mode-output-map (make-sparse-keymap))
+  (define-key py-mode-output-map [button2]  'py-mouseto-exception)
+  (define-key py-mode-output-map &quot;\C-c\C-c&quot; 'py-goto-exception)
+  ;; TBD: Disable all self-inserting keys.  This is bogus, we should
+  ;; really implement this as *Python Output* buffer being read-only
+  (mapcar #' (lambda (key)
+	       (define-key py-mode-output-map key
+		 #'(lambda () (interactive) (beep))))
+	     (where-is-internal 'self-insert-command))
+  )
+
+(defvar py-shell-map nil
+  &quot;Keymap used in *Python* shell buffers.&quot;)
+(if py-shell-map
+    nil
+  (setq py-shell-map (copy-keymap comint-mode-map))
+  (define-key py-shell-map [tab]   'tab-to-tab-stop)
+  (define-key py-shell-map &quot;\C-c-&quot; 'py-up-exception)
+  (define-key py-shell-map &quot;\C-c=&quot; 'py-down-exception)
+  )
+
+(defvar py-mode-syntax-table nil
+  &quot;Syntax table used in `python-mode' buffers.&quot;)
+(when (not py-mode-syntax-table)
+  (setq py-mode-syntax-table (make-syntax-table))
+  (modify-syntax-entry ?\( &quot;()&quot; py-mode-syntax-table)
+  (modify-syntax-entry ?\) &quot;)(&quot; py-mode-syntax-table)
+  (modify-syntax-entry ?\[ &quot;(]&quot; py-mode-syntax-table)
+  (modify-syntax-entry ?\] &quot;)[&quot; py-mode-syntax-table)
+  (modify-syntax-entry ?\{ &quot;(}&quot; py-mode-syntax-table)
+  (modify-syntax-entry ?\} &quot;){&quot; py-mode-syntax-table)
+  ;; Add operator symbols misassigned in the std table
+  (modify-syntax-entry ?\$ &quot;.&quot;  py-mode-syntax-table)
+  (modify-syntax-entry ?\% &quot;.&quot;  py-mode-syntax-table)
+  (modify-syntax-entry ?\&amp; &quot;.&quot;  py-mode-syntax-table)
+  (modify-syntax-entry ?\* &quot;.&quot;  py-mode-syntax-table)
+  (modify-syntax-entry ?\+ &quot;.&quot;  py-mode-syntax-table)
+  (modify-syntax-entry ?\- &quot;.&quot;  py-mode-syntax-table)
+  (modify-syntax-entry ?\/ &quot;.&quot;  py-mode-syntax-table)
+  (modify-syntax-entry ?\&lt; &quot;.&quot;  py-mode-syntax-table)
+  (modify-syntax-entry ?\= &quot;.&quot;  py-mode-syntax-table)
+  (modify-syntax-entry ?\&gt; &quot;.&quot;  py-mode-syntax-table)
+  (modify-syntax-entry ?\| &quot;.&quot;  py-mode-syntax-table)
+  ;; For historical reasons, underscore is word class instead of
+  ;; symbol class.  GNU conventions say it should be symbol class, but
+  ;; there's a natural conflict between what major mode authors want
+  ;; and what users expect from `forward-word' and `backward-word'.
+  ;; Guido and I have hashed this out and have decided to keep
+  ;; underscore in word class.  If you're tempted to change it, try
+  ;; binding M-f and M-b to py-forward-into-nomenclature and
+  ;; py-backward-into-nomenclature instead.  This doesn't help in all
+  ;; situations where you'd want the different behavior
+  ;; (e.g. backward-kill-word).
+  (modify-syntax-entry ?\_ &quot;w&quot;  py-mode-syntax-table)
+  ;; Both single quote and double quote are string delimiters
+  (modify-syntax-entry ?\' &quot;\&quot;&quot; py-mode-syntax-table)
+  (modify-syntax-entry ?\&quot; &quot;\&quot;&quot; py-mode-syntax-table)
+  ;; backquote is open and close paren
+  (modify-syntax-entry ?\` &quot;$&quot;  py-mode-syntax-table)
+  ;; comment delimiters
+  (modify-syntax-entry ?\# &quot;&lt;&quot;  py-mode-syntax-table)
+  (modify-syntax-entry ?\n &quot;&gt;&quot;  py-mode-syntax-table)
+  )
+
+;; An auxiliary syntax table which places underscore and dot in the
+;; symbol class for simplicity
+(defvar py-dotted-expression-syntax-table nil
+  &quot;Syntax table used to identify Python dotted expressions.&quot;)
+(when (not py-dotted-expression-syntax-table)
+  (setq py-dotted-expression-syntax-table
+	(copy-syntax-table py-mode-syntax-table))
+  (modify-syntax-entry ?_ &quot;_&quot; py-dotted-expression-syntax-table)
+  (modify-syntax-entry ?. &quot;_&quot; py-dotted-expression-syntax-table))
+
+
+
+;; Utilities
+(defmacro py-safe (&amp;rest body)
+  &quot;Safely execute BODY, return nil if an error occurred.&quot;
+  (` (condition-case nil
+	 (progn (,@ body))
+       (error nil))))
+
+(defsubst py-keep-region-active ()
+  &quot;Keep the region active in XEmacs.&quot;
+  ;; Ignore byte-compiler warnings you might see.  Also note that
+  ;; FSF's Emacs 19 does it differently; its policy doesn't require us
+  ;; to take explicit action.
+  (and (boundp 'zmacs-region-stays)
+       (setq zmacs-region-stays t)))
+
+(defsubst py-point (position)
+  &quot;Returns the value of point at certain commonly referenced POSITIONs.
+POSITION can be one of the following symbols:
+
+  bol  -- beginning of line
+  eol  -- end of line
+  bod  -- beginning of def or class
+  eod  -- end of def or class
+  bob  -- beginning of buffer
+  eob  -- end of buffer
+  boi  -- back to indentation
+  bos  -- beginning of statement
+
+This function does not modify point or mark.&quot;
+  (let ((here (point)))
+    (cond
+     ((eq position 'bol) (beginning-of-line))
+     ((eq position 'eol) (end-of-line))
+     ((eq position 'bod) (py-beginning-of-def-or-class 'either))
+     ((eq position 'eod) (py-end-of-def-or-class 'either))
+     ;; Kind of funny, I know, but useful for py-up-exception.
+     ((eq position 'bob) (beginning-of-buffer))
+     ((eq position 'eob) (end-of-buffer))
+     ((eq position 'boi) (back-to-indentation))
+     ((eq position 'bos) (py-goto-initial-line))
+     (t (error &quot;Unknown buffer position requested: %s&quot; position))
+     )
+    (prog1
+	(point)
+      (goto-char here))))
+
+(defsubst py-highlight-line (from to file line)
+  (cond
+   ((fboundp 'make-extent)
+    ;; XEmacs
+    (let ((e (make-extent from to)))
+      (set-extent-property e 'mouse-face 'highlight)
+      (set-extent-property e 'py-exc-info (cons file line))
+      (set-extent-property e 'keymap py-mode-output-map)))
+   (t
+    ;; Emacs -- Please port this!
+    )
+   ))
+
+(defun py-in-literal (&amp;optional lim)
+  &quot;Return non-nil if point is in a Python literal (a comment or string).
+Optional argument LIM indicates the beginning of the containing form,
+i.e. the limit on how far back to scan.&quot;
+  ;; This is the version used for non-XEmacs, which has a nicer
+  ;; interface.
+  ;;
+  ;; WARNING: Watch out for infinite recursion.
+  (let* ((lim (or lim (py-point 'bod)))
+	 (state (parse-partial-sexp lim (point))))
+    (cond
+     ((nth 3 state) 'string)
+     ((nth 4 state) 'comment)
+     (t nil))))
+
+;; XEmacs has a built-in function that should make this much quicker.
+;; In this case, lim is ignored
+(defun py-fast-in-literal (&amp;optional lim)
+  &quot;Fast version of `py-in-literal', used only by XEmacs.
+Optional LIM is ignored.&quot;
+  ;; don't have to worry about context == 'block-comment
+  (buffer-syntactic-context))
+
+(if (fboundp 'buffer-syntactic-context)
+    (defalias 'py-in-literal 'py-fast-in-literal))
+
+
+
+;; Menu definitions, only relevent if you have the easymenu.el package
+;; (standard in the latest Emacs 19 and XEmacs 19 distributions).
+(defvar py-menu nil
+  &quot;Menu for Python Mode.
+This menu will get created automatically if you have the `easymenu'
+package.  Note that the latest X/Emacs releases contain this package.&quot;)
+
+(and (py-safe (require 'easymenu) t)
+     (easy-menu-define
+      py-menu py-mode-map &quot;Python Mode menu&quot;
+      '(&quot;Python&quot;
+	[&quot;Comment Out Region&quot;   py-comment-region  (mark)]
+	[&quot;Uncomment Region&quot;     (py-comment-region (point) (mark) '(4)) (mark)]
+	&quot;-&quot;
+	[&quot;Mark current block&quot;   py-mark-block t]
+	[&quot;Mark current def&quot;     py-mark-def-or-class t]
+	[&quot;Mark current class&quot;   (py-mark-def-or-class t) t]
+	&quot;-&quot;
+	[&quot;Shift region left&quot;    py-shift-region-left (mark)]
+	[&quot;Shift region right&quot;   py-shift-region-right (mark)]
+	&quot;-&quot;
+	[&quot;Import/reload file&quot;   py-execute-import-or-reload t]
+	[&quot;Execute buffer&quot;       py-execute-buffer t]
+	[&quot;Execute region&quot;       py-execute-region (mark)]
+	[&quot;Execute def or class&quot; py-execute-def-or-class (mark)]
+	[&quot;Execute string&quot;       py-execute-string t]
+	[&quot;Start interpreter...&quot; py-shell t]
+	&quot;-&quot;
+	[&quot;Go to start of block&quot; py-goto-block-up t]
+	[&quot;Go to start of class&quot; (py-beginning-of-def-or-class t) t]
+	[&quot;Move to end of class&quot; (py-end-of-def-or-class t) t]
+	[&quot;Move to start of def&quot; py-beginning-of-def-or-class t]
+	[&quot;Move to end of def&quot;   py-end-of-def-or-class t]
+	&quot;-&quot;
+	[&quot;Describe mode&quot;        py-describe-mode t]
+	)))
+
+
+
+;; Imenu definitions
+(defvar py-imenu-class-regexp
+  (concat				; &lt;&lt;classes&gt;&gt;
+   &quot;\\(&quot;				;
+   &quot;^[ \t]*&quot;				; newline and maybe whitespace
+   &quot;\\(class[ \t]+[a-zA-Z0-9_]+\\)&quot;	; class name
+					; possibly multiple superclasses
+   &quot;\\([ \t]*\\((\\([a-zA-Z0-9_,. \t\n]\\)*)\\)?\\)&quot;
+   &quot;[ \t]*:&quot;				; and the final :
+   &quot;\\)&quot;				; &gt;&gt;classes&lt;&lt;
+   )
+  &quot;Regexp for Python classes for use with the Imenu package.&quot;
+  )
+
+(defvar py-imenu-method-regexp
+  (concat                               ; &lt;&lt;methods and functions&gt;&gt;
+   &quot;\\(&quot;                                ; 
+   &quot;^[ \t]*&quot;                            ; new line and maybe whitespace
+   &quot;\\(def[ \t]+&quot;                       ; function definitions start with def
+   &quot;\\([a-zA-Z0-9_]+\\)&quot;                ;   name is here
+					;   function arguments...
+;;   &quot;[ \t]*(\\([-+/a-zA-Z0-9_=,\* \t\n.()\&quot;'#]*\\))&quot;
+   &quot;[ \t]*(\\([^:#]*\\))&quot;
+   &quot;\\)&quot;                                ; end of def
+   &quot;[ \t]*:&quot;                            ; and then the :
+   &quot;\\)&quot;                                ; &gt;&gt;methods and functions&lt;&lt;
+   )
+  &quot;Regexp for Python methods/functions for use with the Imenu package.&quot;
+  )
+
+(defvar py-imenu-method-no-arg-parens '(2 8)
+  &quot;Indices into groups of the Python regexp for use with Imenu.
+
+Using these values will result in smaller Imenu lists, as arguments to
+functions are not listed.
+
+See the variable `py-imenu-show-method-args-p' for more
+information.&quot;)
+
+(defvar py-imenu-method-arg-parens '(2 7)
+  &quot;Indices into groups of the Python regexp for use with imenu.
+Using these values will result in large Imenu lists, as arguments to
+functions are listed.
+
+See the variable `py-imenu-show-method-args-p' for more
+information.&quot;)
+
+;; Note that in this format, this variable can still be used with the
+;; imenu--generic-function. Otherwise, there is no real reason to have
+;; it.
+(defvar py-imenu-generic-expression
+  (cons
+   (concat 
+    py-imenu-class-regexp
+    &quot;\\|&quot;				; or...
+    py-imenu-method-regexp
+    )
+   py-imenu-method-no-arg-parens)
+  &quot;Generic Python expression which may be used directly with Imenu.
+Used by setting the variable `imenu-generic-expression' to this value.
+Also, see the function \\[py-imenu-create-index] for a better
+alternative for finding the index.&quot;)
+
+;; These next two variables are used when searching for the Python
+;; class/definitions. Just saving some time in accessing the
+;; generic-python-expression, really.
+(defvar py-imenu-generic-regexp nil)
+(defvar py-imenu-generic-parens nil)
+
+
+(defun py-imenu-create-index-function ()
+  &quot;Python interface function for the Imenu package.
+Finds all Python classes and functions/methods. Calls function
+\\[py-imenu-create-index-engine].  See that function for the details
+of how this works.&quot;
+  (setq py-imenu-generic-regexp (car py-imenu-generic-expression)
+	py-imenu-generic-parens (if py-imenu-show-method-args-p
+				    py-imenu-method-arg-parens
+				  py-imenu-method-no-arg-parens))
+  (goto-char (point-min))
+  ;; Warning: When the buffer has no classes or functions, this will
+  ;; return nil, which seems proper according to the Imenu API, but
+  ;; causes an error in the XEmacs port of Imenu.  Sigh.
+  (py-imenu-create-index-engine nil))
+
+(defun py-imenu-create-index-engine (&amp;optional start-indent)
+  &quot;Function for finding Imenu definitions in Python.
+
+Finds all definitions (classes, methods, or functions) in a Python
+file for the Imenu package.
+
+Returns a possibly nested alist of the form
+
+	(INDEX-NAME . INDEX-POSITION)
+
+The second element of the alist may be an alist, producing a nested
+list as in
+
+	(INDEX-NAME . INDEX-ALIST)
+
+This function should not be called directly, as it calls itself
+recursively and requires some setup.  Rather this is the engine for
+the function \\[py-imenu-create-index-function].
+
+It works recursively by looking for all definitions at the current
+indention level.  When it finds one, it adds it to the alist.  If it
+finds a definition at a greater indentation level, it removes the
+previous definition from the alist. In its place it adds all
+definitions found at the next indentation level.  When it finds a
+definition that is less indented then the current level, it returns
+the alist it has created thus far.
+
+The optional argument START-INDENT indicates the starting indentation
+at which to continue looking for Python classes, methods, or
+functions.  If this is not supplied, the function uses the indentation
+of the first definition found.&quot;
+  (let (index-alist
+	sub-method-alist
+	looking-p
+	def-name prev-name
+	cur-indent def-pos
+	(class-paren (first  py-imenu-generic-parens)) 
+	(def-paren   (second py-imenu-generic-parens)))
+    (setq looking-p
+	  (re-search-forward py-imenu-generic-regexp (point-max) t))
+    (while looking-p
+      (save-excursion
+	;; used to set def-name to this value but generic-extract-name
+	;; is new to imenu-1.14. this way it still works with
+	;; imenu-1.11
+	;;(imenu--generic-extract-name py-imenu-generic-parens))
+	(let ((cur-paren (if (match-beginning class-paren)
+			     class-paren def-paren)))
+	  (setq def-name
+		(buffer-substring-no-properties (match-beginning cur-paren)
+						(match-end cur-paren))))
+	(save-match-data
+	  (py-beginning-of-def-or-class 'either))
+	(beginning-of-line)
+	(setq cur-indent (current-indentation)))
+      ;; HACK: want to go to the next correct definition location.  We
+      ;; explicitly list them here but it would be better to have them
+      ;; in a list.
+      (setq def-pos
+	    (or (match-beginning class-paren)
+		(match-beginning def-paren)))
+      ;; if we don't have a starting indent level, take this one
+      (or start-indent
+	  (setq start-indent cur-indent))
+      ;; if we don't have class name yet, take this one
+      (or prev-name
+	  (setq prev-name def-name))
+      ;; what level is the next definition on?  must be same, deeper
+      ;; or shallower indentation
+      (cond
+       ;; Skip code in comments and strings
+       ((py-in-literal))
+       ;; at the same indent level, add it to the list...
+       ((= start-indent cur-indent)
+	(push (cons def-name def-pos) index-alist))
+       ;; deeper indented expression, recurse
+       ((&lt; start-indent cur-indent)
+	;; the point is currently on the expression we're supposed to
+	;; start on, so go back to the last expression. The recursive
+	;; call will find this place again and add it to the correct
+	;; list
+	(re-search-backward py-imenu-generic-regexp (point-min) 'move)
+	(setq sub-method-alist (py-imenu-create-index-engine cur-indent))
+	(if sub-method-alist
+	    ;; we put the last element on the index-alist on the start
+	    ;; of the submethod alist so the user can still get to it.
+	    (let ((save-elmt (pop index-alist)))
+	      (push (cons prev-name
+			  (cons save-elmt sub-method-alist))
+		    index-alist))))
+       ;; found less indented expression, we're done.
+       (t 
+	(setq looking-p nil)
+	(re-search-backward py-imenu-generic-regexp (point-min) t)))
+      ;; end-cond
+      (setq prev-name def-name)
+      (and looking-p
+	   (setq looking-p
+		 (re-search-forward py-imenu-generic-regexp
+				    (point-max) 'move))))
+    (nreverse index-alist)))
+
+
+
+(defun py-choose-shell-by-shebang ()
+  &quot;Choose CPython or JPython mode by looking at #! on the first line.
+Returns the appropriate mode function.
+Used by `py-choose-shell', and similar to but distinct from
+`set-auto-mode', though it uses `auto-mode-interpreter-regexp' (if available).&quot;
+  ;; look for an interpreter specified in the first line
+  ;; similar to set-auto-mode (files.el)
+  (let* ((re (if (boundp 'auto-mode-interpreter-regexp)
+		 auto-mode-interpreter-regexp
+	       ;; stolen from Emacs 21.2
+	       &quot;#![ \t]?\\([^ \t\n]*/bin/env[ \t]\\)?\\([^ \t\n]+\\)&quot;))
+	 (interpreter (save-excursion
+			(goto-char (point-min))
+			(if (looking-at re)
+			    (match-string 2)
+			  &quot;&quot;)))
+	 elt)
+    ;; Map interpreter name to a mode.
+    (setq elt (assoc (file-name-nondirectory interpreter)
+		     py-shell-alist))
+    (and elt (caddr elt))))
+
+
+
+(defun py-choose-shell-by-import ()
+  &quot;Choose CPython or JPython mode based imports.
+If a file imports any packages in `py-jpython-packages', within
+`py-import-check-point-max' characters from the start of the file,
+return `jpython', otherwise return nil.&quot;
+  (let (mode)
+    (save-excursion
+      (goto-char (point-min))
+      (while (and (not mode)
+		  (search-forward-regexp
+		   &quot;^\\(\\(from\\)\\|\\(import\\)\\) \\([^ \t\n.]+\\)&quot;
+		   py-import-check-point-max t))
+	(setq mode (and (member (match-string 4) py-jpython-packages)
+			'jpython
+			))))
+    mode))
+
+
+(defun py-choose-shell ()
+  &quot;Choose CPython or JPython mode. Returns the appropriate mode function.
+This does the following:
+ - look for an interpreter with `py-choose-shell-by-shebang'
+ - examine imports using `py-choose-shell-by-import'
+ - default to the variable `py-default-interpreter'&quot;
+  (interactive)
+  (or (py-choose-shell-by-shebang)
+      (py-choose-shell-by-import)
+      py-default-interpreter
+;      'cpython ;; don't use to py-default-interpreter, because default
+;               ;; is only way to choose CPython
+      ))
+
+
+;;;###autoload
+(defun python-mode ()
+  &quot;Major mode for editing Python files.
+To submit a problem report, enter `\\[py-submit-bug-report]' from a
+`python-mode' buffer.  Do `\\[py-describe-mode]' for detailed
+documentation.  To see what version of `python-mode' you are running,
+enter `\\[py-version]'.
+
+This mode knows about Python indentation, tokens, comments and
+continuation lines.  Paragraphs are separated by blank lines only.
+
+COMMANDS
+\\{py-mode-map}
+VARIABLES
+
+py-indent-offset\t\tindentation increment
+py-block-comment-prefix\t\tcomment string used by `comment-region'
+py-python-command\t\tshell command to invoke Python interpreter
+py-temp-directory\t\tdirectory used for temp files (if needed)
+py-beep-if-tab-change\t\tring the bell if `tab-width' is changed&quot;
+  (interactive)
+  ;; set up local variables
+  (kill-all-local-variables)
+  (make-local-variable 'font-lock-defaults)
+  (make-local-variable 'paragraph-separate)
+  (make-local-variable 'paragraph-start)
+  (make-local-variable 'require-final-newline)
+  (make-local-variable 'comment-start)
+  (make-local-variable 'comment-end)
+  (make-local-variable 'comment-start-skip)
+  (make-local-variable 'comment-column)
+  (make-local-variable 'comment-indent-function)
+  (make-local-variable 'indent-region-function)
+  (make-local-variable 'indent-line-function)
+  (make-local-variable 'add-log-current-defun-function)
+  (make-local-variable 'fill-paragraph-function)
+  ;;
+  (set-syntax-table py-mode-syntax-table)
+  (setq major-mode              'python-mode
+	mode-name               &quot;Python&quot;
+	local-abbrev-table      python-mode-abbrev-table
+	font-lock-defaults      '(python-font-lock-keywords)
+	paragraph-separate      &quot;^[ \t]*$&quot;
+	paragraph-start         &quot;^[ \t]*$&quot;
+	require-final-newline   t
+	comment-start           &quot;# &quot;
+	comment-end             &quot;&quot;
+	comment-start-skip      &quot;# *&quot;
+	comment-column          40
+	comment-indent-function 'py-comment-indent-function
+	indent-region-function  'py-indent-region
+	indent-line-function    'py-indent-line
+	;; tell add-log.el how to find the current function/method/variable
+	add-log-current-defun-function 'py-current-defun
+
+	fill-paragraph-function 'py-fill-paragraph
+	)
+  (use-local-map py-mode-map)
+  ;; add the menu
+  (if py-menu
+      (easy-menu-add py-menu))
+  ;; Emacs 19 requires this
+  (if (boundp 'comment-multi-line)
+      (setq comment-multi-line nil))
+  ;; Install Imenu if available
+  (when (py-safe (require 'imenu))
+    (setq imenu-create-index-function #'py-imenu-create-index-function)
+    (setq imenu-generic-expression py-imenu-generic-expression)
+    (if (fboundp 'imenu-add-to-menubar)
+	(imenu-add-to-menubar (format &quot;%s-%s&quot; &quot;IM&quot; mode-name)))
+    )
+  ;; Run the mode hook.  Note that py-mode-hook is deprecated.
+  (if python-mode-hook
+      (run-hooks 'python-mode-hook)
+    (run-hooks 'py-mode-hook))
+  ;; Now do the automagical guessing
+  (if py-smart-indentation
+    (let ((offset py-indent-offset))
+      ;; It's okay if this fails to guess a good value
+      (if (and (py-safe (py-guess-indent-offset))
+	       (&lt;= py-indent-offset 8)
+	       (&gt;= py-indent-offset 2))
+	  (setq offset py-indent-offset))
+      (setq py-indent-offset offset)
+      ;; Only turn indent-tabs-mode off if tab-width !=
+      ;; py-indent-offset.  Never turn it on, because the user must
+      ;; have explicitly turned it off.
+      (if (/= tab-width py-indent-offset)
+	  (setq indent-tabs-mode nil))
+      ))
+  ;; Set the default shell if not already set
+  (when (null py-which-shell)
+    (py-toggle-shells (py-choose-shell))))
+
+
+(defun jpython-mode ()
+  &quot;Major mode for editing JPython/Jython files.
+This is a simple wrapper around `python-mode'.
+It runs `jpython-mode-hook' then calls `python-mode.'
+It is added to `interpreter-mode-alist' and `py-choose-shell'.
+&quot;
+  (interactive)
+  (python-mode)
+  (py-toggle-shells 'jpython)
+  (when jpython-mode-hook
+      (run-hooks 'jpython-mode-hook)))
+
+
+;; It's handy to add recognition of Python files to the
+;; interpreter-mode-alist and to auto-mode-alist.  With the former, we
+;; can specify different `derived-modes' based on the #! line, but
+;; with the latter, we can't.  So we just won't add them if they're
+;; already added.
+;;;###autoload
+(let ((modes '((&quot;jpython&quot; . jpython-mode)
+	       (&quot;jython&quot; . jpython-mode)
+	       (&quot;python&quot; . python-mode))))
+  (while modes
+    (when (not (assoc (car modes) interpreter-mode-alist))
+      (push (car modes) interpreter-mode-alist))
+    (setq modes (cdr modes))))
+;;;###autoload
+(when (not (or (rassq 'python-mode auto-mode-alist)
+	       (rassq 'jpython-mode auto-mode-alist)))
+  (push '(&quot;\\.py$&quot; . python-mode) auto-mode-alist))
+
+
+
+;; electric characters
+(defun py-outdent-p ()
+  &quot;Returns non-nil if the current line should dedent one level.&quot;
+  (save-excursion
+    (and (progn (back-to-indentation)
+		(looking-at py-outdent-re))
+	 ;; short circuit infloop on illegal construct
+	 (not (bobp))
+	 (progn (forward-line -1)
+		(py-goto-initial-line)
+		(back-to-indentation)
+		(while (or (looking-at py-blank-or-comment-re)
+			   (bobp))
+		  (backward-to-indentation 1))
+		(not (looking-at py-no-outdent-re)))
+	 )))
+
+(defun py-electric-colon (arg)
+  &quot;Insert a colon.
+In certain cases the line is dedented appropriately.  If a numeric
+argument ARG is provided, that many colons are inserted
+non-electrically.  Electric behavior is inhibited inside a string or
+comment.&quot;
+  (interactive &quot;*P&quot;)
+  (self-insert-command (prefix-numeric-value arg))
+  ;; are we in a string or comment?
+  (if (save-excursion
+	(let ((pps (parse-partial-sexp (save-excursion
+					 (py-beginning-of-def-or-class)
+					 (point))
+				       (point))))
+	  (not (or (nth 3 pps) (nth 4 pps)))))
+      (save-excursion
+	(let ((here (point))
+	      (outdent 0)
+	      (indent (py-compute-indentation t)))
+	  (if (and (not arg)
+		   (py-outdent-p)
+		   (= indent (save-excursion
+			       (py-next-statement -1)
+			       (py-compute-indentation t)))
+		   )
+	      (setq outdent py-indent-offset))
+	  ;; Don't indent, only dedent.  This assumes that any lines
+	  ;; that are already dedented relative to
+	  ;; py-compute-indentation were put there on purpose.  It's
+	  ;; highly annoying to have `:' indent for you.  Use TAB, C-c
+	  ;; C-l or C-c C-r to adjust.  TBD: Is there a better way to
+	  ;; determine this???
+	  (if (&lt; (current-indentation) indent) nil
+	    (goto-char here)
+	    (beginning-of-line)
+	    (delete-horizontal-space)
+	    (indent-to (- indent outdent))
+	    )))))
+
+
+;; Python subprocess utilities and filters
+(defun py-execute-file (proc filename)
+  &quot;Send to Python interpreter process PROC \&quot;execfile('FILENAME')\&quot;.
+Make that process's buffer visible and force display.  Also make
+comint believe the user typed this string so that
+`kill-output-from-shell' does The Right Thing.&quot;
+  (let ((curbuf (current-buffer))
+	(procbuf (process-buffer proc))
+;	(comint-scroll-to-bottom-on-output t)
+	(msg (format &quot;## working on region in file %s...\n&quot; filename))
+	(cmd (format &quot;execfile(r'%s')\n&quot; filename)))
+    (unwind-protect
+	(save-excursion
+	  (set-buffer procbuf)
+	  (goto-char (point-max))
+	  (move-marker (process-mark proc) (point))
+	  (funcall (process-filter proc) proc msg))
+      (set-buffer curbuf))
+    (process-send-string proc cmd)))
+
+(defun py-comint-output-filter-function (string)
+  &quot;Watch output for Python prompt and exec next file waiting in queue.
+This function is appropriate for `comint-output-filter-functions'.&quot;
+  ;; TBD: this should probably use split-string
+  (when (and (or (string-equal string &quot;&gt;&gt;&gt; &quot;)
+		 (and (&gt;= (length string) 5)
+		      (string-equal (substring string -5) &quot;\n&gt;&gt;&gt; &quot;)))
+	     py-file-queue)
+    (pop-to-buffer (current-buffer))
+    (py-safe (delete-file (car py-file-queue)))
+    (setq py-file-queue (cdr py-file-queue))
+    (if py-file-queue
+	(let ((pyproc (get-buffer-process (current-buffer))))
+	  (py-execute-file pyproc (car py-file-queue))))
+    ))
+
+(defun py-pdbtrack-overlay-arrow (activation)
+  &quot;Activate or de arrow at beginning-of-line in current buffer.&quot;
+  ;; This was derived/simplified from edebug-overlay-arrow
+  (cond (activation
+	 (setq overlay-arrow-position (make-marker))
+	 (setq overlay-arrow-string &quot;=&gt;&quot;)
+	 (set-marker overlay-arrow-position (py-point 'bol) (current-buffer))
+	 (setq py-pdbtrack-is-tracking-p t))
+	(overlay-arrow-position
+	 (setq overlay-arrow-position nil)
+	 (setq py-pdbtrack-is-tracking-p nil))
+	))
+
+(defun py-pdbtrack-track-stack-file (text)
+  &quot;Show the file indicated by the pdb stack entry line, in a separate window.
+
+Activity is disabled if the buffer-local variable
+`py-pdbtrack-do-tracking-p' is nil.
+
+We depend on the pdb input prompt matching `py-pdbtrack-input-prompt'
+at the beginning of the line.
+
+If the traceback target file path is invalid, we look for the most
+recently visited python-mode buffer which either has the name of the
+current function \(or class) or which defines the function \(or
+class).  This is to provide for remote scripts, eg, Zope's 'Script
+(Python)' - put a _copy_ of the script in a buffer named for the
+script, and set to python-mode, and pdbtrack will find it.)&quot;
+  ;; Instead of trying to piece things together from partial text
+  ;; (which can be almost useless depending on Emacs version), we
+  ;; monitor to the point where we have the next pdb prompt, and then
+  ;; check all text from comint-last-input-end to process-mark.
+  ;;
+  ;; Also, we're very conservative about clearing the overlay arrow,
+  ;; to minimize residue.  This means, for instance, that executing
+  ;; other pdb commands wipe out the highlight.  You can always do a
+  ;; 'where' (aka 'w') command to reveal the overlay arrow.
+  (let* ((origbuf (current-buffer))
+	 (currproc (get-buffer-process origbuf)))
+
+    (if (not (and currproc py-pdbtrack-do-tracking-p))
+        (py-pdbtrack-overlay-arrow nil)
+
+      (let* ((procmark (process-mark currproc))
+             (block (buffer-substring (max comint-last-input-end
+                                           (- procmark
+                                              py-pdbtrack-track-range))
+                                      procmark))
+             target target_fname target_lineno target_buffer)
+
+        (if (not (string-match (concat py-pdbtrack-input-prompt &quot;$&quot;) block))
+            (py-pdbtrack-overlay-arrow nil)
+
+          (setq target (py-pdbtrack-get-source-buffer block))
+
+          (if (stringp target)
+              (message &quot;pdbtrack: %s&quot; target)
+
+            (setq target_lineno (car target))
+            (setq target_buffer (cadr target))
+            (setq target_fname (buffer-file-name target_buffer))
+            (switch-to-buffer-other-window target_buffer)
+            (goto-line target_lineno)
+            (message &quot;pdbtrack: line %s, file %s&quot; target_lineno target_fname)
+            (py-pdbtrack-overlay-arrow t)
+            (pop-to-buffer origbuf t)
+
+            )))))
+  )
+
+(defun py-pdbtrack-get-source-buffer (block)
+  &quot;Return line number and buffer of code indicated by block's traceback text.
+
+We look first to visit the file indicated in the trace.
+
+Failing that, we look for the most recently visited python-mode buffer
+with the same name or having 
+having the named function.
+
+If we're unable find the source code we return a string describing the
+problem as best as we can determine.&quot;
+
+  (if (not (string-match py-pdbtrack-stack-entry-regexp block))
+
+      &quot;Traceback cue not found&quot;
+
+    (let* ((filename (match-string 1 block))
+           (lineno (string-to-int (match-string 2 block)))
+           (funcname (match-string 3 block))
+           funcbuffer)
+
+      (cond ((file-exists-p filename)
+             (list lineno (find-file-noselect filename)))
+
+            ((setq funcbuffer (py-pdbtrack-grub-for-buffer funcname lineno))
+             (if (string-match &quot;/Script (Python)$&quot; filename)
+                 ;; Add in number of lines for leading '##' comments:
+                 (setq lineno
+                       (+ lineno
+                          (save-excursion
+                            (set-buffer funcbuffer)
+                            (count-lines
+                             (point-min)
+                             (max (point-min)
+                                  (string-match &quot;^\\([^#]\\|#[^#]\\|#$\\)&quot;
+                                                (buffer-substring (point-min)
+                                                                  (point-max)))
+                                  ))))))
+             (list lineno funcbuffer))
+
+            ((= (elt filename 0) ?\&lt;)
+             (format &quot;(Non-file source: '%s')&quot; filename))
+
+            (t (format &quot;Not found: %s(), %s&quot; funcname filename)))
+      )
+    )
+  )
+
+(defun py-pdbtrack-grub-for-buffer (funcname lineno)
+  &quot;Find most recent buffer itself named or having function funcname.
+
+We walk the buffer-list history for python-mode buffers that are
+named for funcname or define a function funcname.&quot;
+  (let ((buffers (buffer-list))
+        buf
+        got)
+    (while (and buffers (not got))
+      (setq buf (car buffers)
+            buffers (cdr buffers))
+      (if (and (save-excursion (set-buffer buf)
+                               (string= major-mode &quot;python-mode&quot;))
+               (or (string-match funcname (buffer-name buf))
+                   (string-match (concat &quot;^\\s-*\\(def\\|class\\)\\s-+&quot;
+                                         funcname &quot;\\s-*(&quot;)
+                                 (save-excursion
+                                   (set-buffer buf)
+                                   (buffer-substring (point-min)
+                                                     (point-max))))))
+          (setq got buf)))
+    got))
+
+(defun py-postprocess-output-buffer (buf)
+  &quot;Highlight exceptions found in BUF.
+If an exception occurred return t, otherwise return nil.  BUF must exist.&quot;
+  (let (line file bol err-p)
+    (save-excursion
+      (set-buffer buf)
+      (beginning-of-buffer)
+      (while (re-search-forward py-traceback-line-re nil t)
+	(setq file (match-string 1)
+	      line (string-to-int (match-string 2))
+	      bol (py-point 'bol))
+	(py-highlight-line bol (py-point 'eol) file line)))
+    (when (and py-jump-on-exception line)
+      (beep)
+      (py-jump-to-exception file line)
+      (setq err-p t))
+    err-p))
+
+
+
+;;; Subprocess commands
+
+;; only used when (memq 'broken-temp-names py-emacs-features)
+(defvar py-serial-number 0)
+(defvar py-exception-buffer nil)
+(defconst py-output-buffer &quot;*Python Output*&quot;)
+(make-variable-buffer-local 'py-output-buffer)
+
+;; for toggling between CPython and JPython
+(defvar py-which-shell nil)
+(defvar py-which-args  py-python-command-args)
+(defvar py-which-bufname &quot;Python&quot;)
+(make-variable-buffer-local 'py-which-shell)
+(make-variable-buffer-local 'py-which-args)
+(make-variable-buffer-local 'py-which-bufname)
+
+(defun py-toggle-shells (arg)
+  &quot;Toggles between the CPython and JPython shells.
+
+With positive argument ARG (interactively \\[universal-argument]),
+uses the CPython shell, with negative ARG uses the JPython shell, and
+with a zero argument, toggles the shell.
+
+Programmatically, ARG can also be one of the symbols `cpython' or
+`jpython', equivalent to positive arg and negative arg respectively.&quot;
+  (interactive &quot;P&quot;)
+  ;; default is to toggle
+  (if (null arg)
+      (setq arg 0))
+  ;; preprocess arg
+  (cond
+   ((equal arg 0)
+    ;; toggle
+    (if (string-equal py-which-bufname &quot;Python&quot;)
+	(setq arg -1)
+      (setq arg 1)))
+   ((equal arg 'cpython) (setq arg 1))
+   ((equal arg 'jpython) (setq arg -1)))
+  (let (msg)
+    (cond
+     ((&lt; 0 arg)
+      ;; set to CPython
+      (setq py-which-shell py-python-command
+	    py-which-args py-python-command-args
+	    py-which-bufname &quot;Python&quot;
+	    msg &quot;CPython&quot;
+	    mode-name &quot;Python&quot;))
+     ((&gt; 0 arg)
+      (setq py-which-shell py-jpython-command
+	    py-which-args py-jpython-command-args
+	    py-which-bufname &quot;JPython&quot;
+	    msg &quot;JPython&quot;
+	    mode-name &quot;JPython&quot;))
+     )
+    (message &quot;Using the %s shell&quot; msg)
+    (setq py-output-buffer (format &quot;*%s Output*&quot; py-which-bufname))))
+
+;;;###autoload
+(defun py-shell (&amp;optional argprompt)
+  &quot;Start an interactive Python interpreter in another window.
+This is like Shell mode, except that Python is running in the window
+instead of a shell.  See the `Interactive Shell' and `Shell Mode'
+sections of the Emacs manual for details, especially for the key
+bindings active in the `*Python*' buffer.
+
+With optional \\[universal-argument], the user is prompted for the
+flags to pass to the Python interpreter.  This has no effect when this
+command is used to switch to an existing process, only when a new
+process is started.  If you use this, you will probably want to ensure
+that the current arguments are retained (they will be included in the
+prompt).  This argument is ignored when this function is called
+programmatically, or when running in Emacs 19.34 or older.
+
+Note: You can toggle between using the CPython interpreter and the
+JPython interpreter by hitting \\[py-toggle-shells].  This toggles
+buffer local variables which control whether all your subshell
+interactions happen to the `*JPython*' or `*Python*' buffers (the
+latter is the name used for the CPython buffer).
+
+Warning: Don't use an interactive Python if you change sys.ps1 or
+sys.ps2 from their default values, or if you're running code that
+prints `&gt;&gt;&gt; ' or `... ' at the start of a line.  `python-mode' can't
+distinguish your output from Python's output, and assumes that `&gt;&gt;&gt; '
+at the start of a line is a prompt from Python.  Similarly, the Emacs
+Shell mode code assumes that both `&gt;&gt;&gt; ' and `... ' at the start of a
+line are Python prompts.  Bad things can happen if you fool either
+mode.
+
+Warning:  If you do any editing *in* the process buffer *while* the
+buffer is accepting output from Python, do NOT attempt to `undo' the
+changes.  Some of the output (nowhere near the parts you changed!) may
+be lost if you do.  This appears to be an Emacs bug, an unfortunate
+interaction between undo and process filters; the same problem exists in
+non-Python process buffers using the default (Emacs-supplied) process
+filter.&quot;
+  (interactive &quot;P&quot;)
+  ;; Set the default shell if not already set
+  (when (null py-which-shell)
+    (py-toggle-shells py-default-interpreter))
+  (let ((args py-which-args))
+    (when (and argprompt
+	       (interactive-p)
+	       (fboundp 'split-string))
+      ;; TBD: Perhaps force &quot;-i&quot; in the final list?
+      (setq args (split-string
+		  (read-string (concat py-which-bufname
+				       &quot; arguments: &quot;)
+			       (concat
+				(mapconcat 'identity py-which-args &quot; &quot;) &quot; &quot;)
+			       ))))
+    (switch-to-buffer-other-window
+     (apply 'make-comint py-which-bufname py-which-shell nil args))
+    (make-local-variable 'comint-prompt-regexp)
+    (setq comint-prompt-regexp &quot;^&gt;&gt;&gt; \\|^[.][.][.] \\|^(pdb) &quot;)
+    (add-hook 'comint-output-filter-functions
+	      'py-comint-output-filter-function)
+    ;; pdbtrack
+    (add-hook 'comint-output-filter-functions 'py-pdbtrack-track-stack-file)
+    (setq py-pdbtrack-do-tracking-p t)
+    (set-syntax-table py-mode-syntax-table)
+    (use-local-map py-shell-map)
+    (run-hooks 'py-shell-hook)
+    ))
+
+(defun py-clear-queue ()
+  &quot;Clear the queue of temporary files waiting to execute.&quot;
+  (interactive)
+  (let ((n (length py-file-queue)))
+    (mapcar 'delete-file py-file-queue)
+    (setq py-file-queue nil)
+    (message &quot;%d pending files de-queued.&quot; n)))
+
+
+(defun py-execute-region (start end &amp;optional async)
+  &quot;Execute the region in a Python interpreter.
+
+The region is first copied into a temporary file (in the directory
+`py-temp-directory').  If there is no Python interpreter shell
+running, this file is executed synchronously using
+`shell-command-on-region'.  If the program is long running, use
+\\[universal-argument] to run the command asynchronously in its own
+buffer.
+
+When this function is used programmatically, arguments START and END
+specify the region to execute, and optional third argument ASYNC, if
+non-nil, specifies to run the command asynchronously in its own
+buffer.
+
+If the Python interpreter shell is running, the region is execfile()'d
+in that shell.  If you try to execute regions too quickly,
+`python-mode' will queue them up and execute them one at a time when
+it sees a `&gt;&gt;&gt; ' prompt from Python.  Each time this happens, the
+process buffer is popped into a window (if it's not already in some
+window) so you can see it, and a comment of the form
+
+    \t## working on region in file &lt;name&gt;...
+
+is inserted at the end.  See also the command `py-clear-queue'.&quot;
+  (interactive &quot;r\nP&quot;)
+  ;; Skip ahead to the first non-blank line
+  (let* ((proc (get-process py-which-bufname))
+	 (temp (if (memq 'broken-temp-names py-emacs-features)
+		   (let
+		       ((sn py-serial-number)
+			(pid (and (fboundp 'emacs-pid) (emacs-pid))))
+		     (setq py-serial-number (1+ py-serial-number))
+		     (if pid
+			 (format &quot;python-%d-%d&quot; sn pid)
+		       (format &quot;python-%d&quot; sn)))
+		 (make-temp-name &quot;python-&quot;)))
+	 (file (concat (expand-file-name temp py-temp-directory) &quot;.py&quot;))
+	 (cur (current-buffer))
+	 (buf (get-buffer-create file))
+	 shell)
+    ;; Write the contents of the buffer, watching out for indented regions.
+    (save-excursion
+      (goto-char start)
+      (beginning-of-line)
+      (while (and (looking-at &quot;\\s *$&quot;)
+		  (&lt; (point) end))
+	(forward-line 1))
+      (setq start (point))
+      (or (&lt; start end)
+	  (error &quot;Region is empty&quot;))
+      (let ((needs-if (/= (py-point 'bol) (py-point 'boi))))
+	(set-buffer buf)
+	(python-mode)
+	(when needs-if
+	  (insert &quot;if 1:\n&quot;))
+	(insert-buffer-substring cur start end)
+	;; Set the shell either to the #! line command, or to the
+	;; py-which-shell buffer local variable.
+	(setq shell (or (py-choose-shell-by-shebang)
+			(py-choose-shell-by-import)
+			py-which-shell))))
+    (cond
+     ;; always run the code in its own asynchronous subprocess
+     (async
+      ;; User explicitly wants this to run in its own async subprocess
+      (save-excursion
+	(set-buffer buf)
+	(write-region (point-min) (point-max) file nil 'nomsg))
+      (let* ((buf (generate-new-buffer-name py-output-buffer))
+	     ;; TBD: a horrible hack, but why create new Custom variables?
+	     (arg (if (string-equal py-which-bufname &quot;Python&quot;)
+		      &quot;-u&quot; &quot;&quot;)))
+	(start-process py-which-bufname buf shell arg file)
+	(pop-to-buffer buf)
+	(py-postprocess-output-buffer buf)
+	;; TBD: clean up the temporary file!
+	))
+     ;; if the Python interpreter shell is running, queue it up for
+     ;; execution there.
+     (proc
+      ;; use the existing python shell
+      (save-excursion
+	(set-buffer buf)
+	(write-region (point-min) (point-max) file nil 'nomsg))
+      (if (not py-file-queue)
+	  (py-execute-file proc file)
+	(message &quot;File %s queued for execution&quot; file))
+      (setq py-file-queue (append py-file-queue (list file)))
+      (setq py-exception-buffer (cons file (current-buffer))))
+     (t
+      ;; TBD: a horrible hack, but why create new Custom variables?
+      (let ((cmd (concat shell (if (string-equal py-which-bufname &quot;JPython&quot;)
+				   &quot; -&quot; &quot;&quot;))))
+	;; otherwise either run it synchronously in a subprocess
+	(save-excursion
+	  (set-buffer buf)
+	  (shell-command-on-region (point-min) (point-max)
+				   cmd py-output-buffer))
+	;; shell-command-on-region kills the output buffer if it never
+	;; existed and there's no output from the command
+	(if (not (get-buffer py-output-buffer))
+	    (message &quot;No output.&quot;)
+	  (setq py-exception-buffer (current-buffer))
+	  (let ((err-p (py-postprocess-output-buffer py-output-buffer)))
+	    (pop-to-buffer py-output-buffer)
+	    (if err-p
+		(pop-to-buffer py-exception-buffer)))
+	  ))
+      ))
+    ;; Clean up after ourselves.
+    (kill-buffer buf)))
+
+
+;; Code execution commands
+(defun py-execute-buffer (&amp;optional async)
+  &quot;Send the contents of the buffer to a Python interpreter.
+If the file local variable `py-master-file' is non-nil, execute the
+named file instead of the buffer's file.
+
+If there is a *Python* process buffer it is used.  If a clipping
+restriction is in effect, only the accessible portion of the buffer is
+sent.  A trailing newline will be supplied if needed.
+
+See the `\\[py-execute-region]' docs for an account of some
+subtleties, including the use of the optional ASYNC argument.&quot;
+  (interactive &quot;P&quot;)
+  (if py-master-file
+      (let* ((filename (expand-file-name py-master-file))
+	     (buffer (or (get-file-buffer filename)
+			 (find-file-noselect filename))))
+	(set-buffer buffer)))
+  (py-execute-region (point-min) (point-max) async))
+
+(defun py-execute-import-or-reload (&amp;optional async)
+  &quot;Import the current buffer's file in a Python interpreter.
+
+If the file has already been imported, then do reload instead to get
+the latest version.
+
+If the file's name does not end in \&quot;.py\&quot;, then do execfile instead.
+
+If the current buffer is not visiting a file, do `py-execute-buffer'
+instead.
+
+If the file local variable `py-master-file' is non-nil, import or
+reload the named file instead of the buffer's file.  The file may be
+saved based on the value of `py-execute-import-or-reload-save-p'.
+
+See the `\\[py-execute-region]' docs for an account of some
+subtleties, including the use of the optional ASYNC argument.
+
+This may be preferable to `\\[py-execute-buffer]' because:
+
+ - Definitions stay in their module rather than appearing at top
+   level, where they would clutter the global namespace and not affect
+   uses of qualified names (MODULE.NAME).
+
+ - The Python debugger gets line number information about the functions.&quot;
+  (interactive &quot;P&quot;)
+  ;; Check file local variable py-master-file
+  (if py-master-file
+      (let* ((filename (expand-file-name py-master-file))
+             (buffer (or (get-file-buffer filename)
+                         (find-file-noselect filename))))
+        (set-buffer buffer)))
+  (let ((file (buffer-file-name (current-buffer))))
+    (if file
+        (progn
+	  ;; Maybe save some buffers
+	  (save-some-buffers (not py-ask-about-save) nil)
+          (py-execute-string
+           (if (string-match &quot;\\.py$&quot; file)
+               (let ((f (file-name-sans-extension
+			 (file-name-nondirectory file))))
+                 (format &quot;if globals().has_key('%s'):\n    reload(%s)\nelse:\n    import %s\n&quot;
+                         f f f))
+             (format &quot;execfile(r'%s')\n&quot; file))
+           async))
+      ;; else
+      (py-execute-buffer async))))
+
+
+(defun py-execute-def-or-class (&amp;optional async)
+  &quot;Send the current function or class definition to a Python interpreter.
+
+If there is a *Python* process buffer it is used.
+
+See the `\\[py-execute-region]' docs for an account of some
+subtleties, including the use of the optional ASYNC argument.&quot;
+  (interactive &quot;P&quot;)
+  (save-excursion
+    (py-mark-def-or-class)
+    ;; mark is before point
+    (py-execute-region (mark) (point) async)))
+
+
+(defun py-execute-string (string &amp;optional async)
+  &quot;Send the argument STRING to a Python interpreter.
+
+If there is a *Python* process buffer it is used.
+
+See the `\\[py-execute-region]' docs for an account of some
+subtleties, including the use of the optional ASYNC argument.&quot;
+  (interactive &quot;sExecute Python command: &quot;)
+  (save-excursion
+    (set-buffer (get-buffer-create
+                 (generate-new-buffer-name &quot; *Python Command*&quot;)))
+    (insert string)
+    (py-execute-region (point-min) (point-max) async)))
+
+
+
+(defun py-jump-to-exception (file line)
+  &quot;Jump to the Python code in FILE at LINE.&quot;
+  (let ((buffer (cond ((string-equal file &quot;&lt;stdin&gt;&quot;)
+		       (if (consp py-exception-buffer)
+			   (cdr py-exception-buffer)
+			 py-exception-buffer))
+		      ((and (consp py-exception-buffer)
+			    (string-equal file (car py-exception-buffer)))
+		       (cdr py-exception-buffer))
+		      ((py-safe (find-file-noselect file)))
+		      ;; could not figure out what file the exception
+		      ;; is pointing to, so prompt for it
+		      (t (find-file (read-file-name &quot;Exception file: &quot;
+						    nil
+						    file t))))))
+    (pop-to-buffer buffer)
+    ;; Force Python mode
+    (if (not (eq major-mode 'python-mode))
+	(python-mode))
+    (goto-line line)
+    (message &quot;Jumping to exception in file %s on line %d&quot; file line)))
+
+(defun py-mouseto-exception (event)
+  &quot;Jump to the code which caused the Python exception at EVENT.
+EVENT is usually a mouse click.&quot;
+  (interactive &quot;e&quot;)
+  (cond
+   ((fboundp 'event-point)
+    ;; XEmacs
+    (let* ((point (event-point event))
+	   (buffer (event-buffer event))
+	   (e (and point buffer (extent-at point buffer 'py-exc-info)))
+	   (info (and e (extent-property e 'py-exc-info))))
+      (message &quot;Event point: %d, info: %s&quot; point info)
+      (and info
+	   (py-jump-to-exception (car info) (cdr info)))
+      ))
+   ;; Emacs -- Please port this!
+   ))
+
+(defun py-goto-exception ()
+  &quot;Go to the line indicated by the traceback.&quot;
+  (interactive)
+  (let (file line)
+    (save-excursion
+      (beginning-of-line)
+      (if (looking-at py-traceback-line-re)
+	  (setq file (match-string 1)
+		line (string-to-int (match-string 2)))))
+    (if (not file)
+	(error &quot;Not on a traceback line&quot;))
+    (py-jump-to-exception file line)))
+
+(defun py-find-next-exception (start buffer searchdir errwhere)
+  &quot;Find the next Python exception and jump to the code that caused it.
+START is the buffer position in BUFFER from which to begin searching
+for an exception.  SEARCHDIR is a function, either
+`re-search-backward' or `re-search-forward' indicating the direction
+to search.  ERRWHERE is used in an error message if the limit (top or
+bottom) of the trackback stack is encountered.&quot;
+  (let (file line)
+    (save-excursion
+      (set-buffer buffer)
+      (goto-char (py-point start))
+      (if (funcall searchdir py-traceback-line-re nil t)
+	  (setq file (match-string 1)
+		line (string-to-int (match-string 2)))))
+    (if (and file line)
+	(py-jump-to-exception file line)
+      (error &quot;%s of traceback&quot; errwhere))))
+
+(defun py-down-exception (&amp;optional bottom)
+  &quot;Go to the next line down in the traceback.
+With \\[univeral-argument] (programmatically, optional argument
+BOTTOM), jump to the bottom (innermost) exception in the exception
+stack.&quot;
+  (interactive &quot;P&quot;)
+  (let* ((proc (get-process &quot;Python&quot;))
+	 (buffer (if proc &quot;*Python*&quot; py-output-buffer)))
+    (if bottom
+	(py-find-next-exception 'eob buffer 're-search-backward &quot;Bottom&quot;)
+      (py-find-next-exception 'eol buffer 're-search-forward &quot;Bottom&quot;))))
+
+(defun py-up-exception (&amp;optional top)
+  &quot;Go to the previous line up in the traceback.
+With \\[universal-argument] (programmatically, optional argument TOP)
+jump to the top (outermost) exception in the exception stack.&quot;
+  (interactive &quot;P&quot;)
+  (let* ((proc (get-process &quot;Python&quot;))
+	 (buffer (if proc &quot;*Python*&quot; py-output-buffer)))
+    (if top
+	(py-find-next-exception 'bob buffer 're-search-forward &quot;Top&quot;)
+      (py-find-next-exception 'bol buffer 're-search-backward &quot;Top&quot;))))
+
+
+;; Electric deletion
+(defun py-electric-backspace (arg)
+  &quot;Delete preceding character or levels of indentation.
+Deletion is performed by calling the function in `py-backspace-function'
+with a single argument (the number of characters to delete).
+
+If point is at the leftmost column, delete the preceding newline.
+
+Otherwise, if point is at the leftmost non-whitespace character of a
+line that is neither a continuation line nor a non-indenting comment
+line, or if point is at the end of a blank line, this command reduces
+the indentation to match that of the line that opened the current
+block of code.  The line that opened the block is displayed in the
+echo area to help you keep track of where you are.  With
+\\[universal-argument] dedents that many blocks (but not past column
+zero).
+
+Otherwise the preceding character is deleted, converting a tab to
+spaces if needed so that only a single column position is deleted.
+\\[universal-argument] specifies how many characters to delete;
+default is 1.
+
+When used programmatically, argument ARG specifies the number of
+blocks to dedent, or the number of characters to delete, as indicated
+above.&quot;
+  (interactive &quot;*p&quot;)
+  (if (or (/= (current-indentation) (current-column))
+	  (bolp)
+	  (py-continuation-line-p)
+;	  (not py-honor-comment-indentation)
+;	  (looking-at &quot;#[^ \t\n]&quot;)	; non-indenting #
+	  )
+      (funcall py-backspace-function arg)
+    ;; else indent the same as the colon line that opened the block
+    ;; force non-blank so py-goto-block-up doesn't ignore it
+    (insert-char ?* 1)
+    (backward-char)
+    (let ((base-indent 0)		; indentation of base line
+	  (base-text &quot;&quot;)		; and text of base line
+	  (base-found-p nil))
+      (save-excursion
+	(while (&lt; 0 arg)
+	  (condition-case nil		; in case no enclosing block
+	      (progn
+		(py-goto-block-up 'no-mark)
+		(setq base-indent (current-indentation)
+		      base-text   (py-suck-up-leading-text)
+		      base-found-p t))
+	    (error nil))
+	  (setq arg (1- arg))))
+      (delete-char 1)			; toss the dummy character
+      (delete-horizontal-space)
+      (indent-to base-indent)
+      (if base-found-p
+	  (message &quot;Closes block: %s&quot; base-text)))))
+
+
+(defun py-electric-delete (arg)
+  &quot;Delete preceding or following character or levels of whitespace.
+
+The behavior of this function depends on the variable
+`delete-key-deletes-forward'.  If this variable is nil (or does not
+exist, as in older Emacsen and non-XEmacs versions), then this
+function behaves identically to \\[c-electric-backspace].
+
+If `delete-key-deletes-forward' is non-nil and is supported in your
+Emacs, then deletion occurs in the forward direction, by calling the
+function in `py-delete-function'.
+
+\\[universal-argument] (programmatically, argument ARG) specifies the
+number of characters to delete (default is 1).&quot;
+  (interactive &quot;*p&quot;)
+  (if (or (and (fboundp 'delete-forward-p) ;XEmacs 21
+	       (delete-forward-p))
+	  (and (boundp 'delete-key-deletes-forward) ;XEmacs 20
+	       delete-key-deletes-forward))
+      (funcall py-delete-function arg)
+    (py-electric-backspace arg)))
+
+;; required for pending-del and delsel modes
+(put 'py-electric-colon 'delete-selection t) ;delsel
+(put 'py-electric-colon 'pending-delete   t) ;pending-del
+(put 'py-electric-backspace 'delete-selection 'supersede) ;delsel
+(put 'py-electric-backspace 'pending-delete   'supersede) ;pending-del
+(put 'py-electric-delete    'delete-selection 'supersede) ;delsel
+(put 'py-electric-delete    'pending-delete   'supersede) ;pending-del
+
+
+
+(defun py-indent-line (&amp;optional arg)
+  &quot;Fix the indentation of the current line according to Python rules.
+With \\[universal-argument] (programmatically, the optional argument
+ARG non-nil), ignore dedenting rules for block closing statements
+(e.g. return, raise, break, continue, pass)
+
+This function is normally bound to `indent-line-function' so
+\\[indent-for-tab-command] will call it.&quot;
+  (interactive &quot;P&quot;)
+  (let* ((ci (current-indentation))
+	 (move-to-indentation-p (&lt;= (current-column) ci))
+	 (need (py-compute-indentation (not arg)))
+         (cc (current-column)))
+    ;; dedent out a level unless we're in column 1
+    (if (and (equal last-command this-command)
+             (/= cc 0))
+        (progn
+          (beginning-of-line)
+          (delete-horizontal-space)
+          (indent-to (* (/ (- cc 1) py-indent-offset) py-indent-offset)))
+      (progn
+	;; see if we need to dedent
+	(if (py-outdent-p)
+	    (setq need (- need py-indent-offset)))
+	(if (/= ci need)
+	    (save-excursion
+	      (beginning-of-line)
+	      (delete-horizontal-space)
+	      (indent-to need)))
+	(if move-to-indentation-p (back-to-indentation))))))
+
+(defun py-newline-and-indent ()
+  &quot;Strives to act like the Emacs `newline-and-indent'.
+This is just `strives to' because correct indentation can't be computed
+from scratch for Python code.  In general, deletes the whitespace before
+point, inserts a newline, and takes an educated guess as to how you want
+the new line indented.&quot;
+  (interactive)
+  (let ((ci (current-indentation)))
+    (if (&lt; ci (current-column))		; if point beyond indentation
+	(newline-and-indent)
+      ;; else try to act like newline-and-indent &quot;normally&quot; acts
+      (beginning-of-line)
+      (insert-char ?\n 1)
+      (move-to-column ci))))
+
+(defun py-compute-indentation (honor-block-close-p)
+  &quot;Compute Python indentation.
+When HONOR-BLOCK-CLOSE-P is non-nil, statements such as `return',
+`raise', `break', `continue', and `pass' force one level of
+dedenting.&quot;
+  (save-excursion
+    (beginning-of-line)
+    (let* ((bod (py-point 'bod))
+	   (pps (parse-partial-sexp bod (point)))
+	   (boipps (parse-partial-sexp bod (py-point 'boi)))
+	   placeholder)
+      (cond
+       ;; are we inside a multi-line string or comment?
+       ((or (and (nth 3 pps) (nth 3 boipps))
+	    (and (nth 4 pps) (nth 4 boipps)))
+	(save-excursion
+	  (if (not py-align-multiline-strings-p) 0
+	    ;; skip back over blank &amp; non-indenting comment lines
+	    ;; note: will skip a blank or non-indenting comment line
+	    ;; that happens to be a continuation line too
+	    (re-search-backward &quot;^[ \t]*\\([^ \t\n#]\\|#[ \t\n]\\)&quot; nil 'move)
+	    (back-to-indentation)
+	    (current-column))))
+       ;; are we on a continuation line?
+       ((py-continuation-line-p)
+	(let ((startpos (point))
+	      (open-bracket-pos (py-nesting-level))
+	      endpos searching found state)
+	  (if open-bracket-pos
+	      (progn
+		;; align with first item in list; else a normal
+		;; indent beyond the line with the open bracket
+		(goto-char (1+ open-bracket-pos)) ; just beyond bracket
+		;; is the first list item on the same line?
+		(skip-chars-forward &quot; \t&quot;)
+		(if (null (memq (following-char) '(?\n ?# ?\\)))
+					; yes, so line up with it
+		    (current-column)
+		  ;; first list item on another line, or doesn't exist yet
+		  (forward-line 1)
+		  (while (and (&lt; (point) startpos)
+			      (looking-at &quot;[ \t]*[#\n\\\\]&quot;)) ; skip noise
+		    (forward-line 1))
+		  (if (and (&lt; (point) startpos)
+			   (/= startpos
+			       (save-excursion
+				 (goto-char (1+ open-bracket-pos))
+				 (forward-comment (point-max))
+				 (point))))
+		      ;; again mimic the first list item
+		      (current-indentation)
+		    ;; else they're about to enter the first item
+		    (goto-char open-bracket-pos)
+		    (setq placeholder (point))
+		    (py-goto-initial-line)
+		    (py-goto-beginning-of-tqs
+		     (save-excursion (nth 3 (parse-partial-sexp
+					     placeholder (point)))))
+		    (+ (current-indentation) py-indent-offset))))
+
+	    ;; else on backslash continuation line
+	    (forward-line -1)
+	    (if (py-continuation-line-p) ; on at least 3rd line in block
+		(current-indentation)	; so just continue the pattern
+	      ;; else started on 2nd line in block, so indent more.
+	      ;; if base line is an assignment with a start on a RHS,
+	      ;; indent to 2 beyond the leftmost &quot;=&quot;; else skip first
+	      ;; chunk of non-whitespace characters on base line, + 1 more
+	      ;; column
+	      (end-of-line)
+	      (setq endpos (point)
+		    searching t)
+	      (back-to-indentation)
+	      (setq startpos (point))
+	      ;; look at all &quot;=&quot; from left to right, stopping at first
+	      ;; one not nested in a list or string
+	      (while searching
+		(skip-chars-forward &quot;^=&quot; endpos)
+		(if (= (point) endpos)
+		    (setq searching nil)
+		  (forward-char 1)
+		  (setq state (parse-partial-sexp startpos (point)))
+		  (if (and (zerop (car state)) ; not in a bracket
+			   (null (nth 3 state))) ; &amp; not in a string
+		      (progn
+			(setq searching nil) ; done searching in any case
+			(setq found
+			      (not (or
+				    (eq (following-char) ?=)
+				    (memq (char-after (- (point) 2))
+					  '(?&lt; ?&gt; ?!)))))))))
+	      (if (or (not found)	; not an assignment
+		      (looking-at &quot;[ \t]*\\\\&quot;)) ; &lt;=&gt;&lt;spaces&gt;&lt;backslash&gt;
+		  (progn
+		    (goto-char startpos)
+		    (skip-chars-forward &quot;^ \t\n&quot;)))
+	      ;; if this is a continuation for a block opening
+	      ;; statement, add some extra offset.
+	      (+ (current-column) (if (py-statement-opens-block-p)
+				      py-continuation-offset 0)
+		 1)
+	      ))))
+
+       ;; not on a continuation line
+       ((bobp) (current-indentation))
+
+       ;; Dfn: &quot;Indenting comment line&quot;.  A line containing only a
+       ;; comment, but which is treated like a statement for
+       ;; indentation calculation purposes.  Such lines are only
+       ;; treated specially by the mode; they are not treated
+       ;; specially by the Python interpreter.
+
+       ;; The rules for indenting comment lines are a line where:
+       ;;   - the first non-whitespace character is `#', and
+       ;;   - the character following the `#' is whitespace, and
+       ;;   - the line is dedented with respect to (i.e. to the left
+       ;;     of) the indentation of the preceding non-blank line.
+
+       ;; The first non-blank line following an indenting comment
+       ;; line is given the same amount of indentation as the
+       ;; indenting comment line.
+
+       ;; All other comment-only lines are ignored for indentation
+       ;; purposes.
+
+       ;; Are we looking at a comment-only line which is *not* an
+       ;; indenting comment line?  If so, we assume that it's been
+       ;; placed at the desired indentation, so leave it alone.
+       ;; Indenting comment lines are aligned as statements down
+       ;; below.
+       ((and (looking-at &quot;[ \t]*#[^ \t\n]&quot;)
+	     ;; NOTE: this test will not be performed in older Emacsen
+	     (fboundp 'forward-comment)
+	     (&lt;= (current-indentation)
+		 (save-excursion
+		   (forward-comment (- (point-max)))
+		   (current-indentation))))
+	(current-indentation))
+
+       ;; else indentation based on that of the statement that
+       ;; precedes us; use the first line of that statement to
+       ;; establish the base, in case the user forced a non-std
+       ;; indentation for the continuation lines (if any)
+       (t
+	;; skip back over blank &amp; non-indenting comment lines note:
+	;; will skip a blank or non-indenting comment line that
+	;; happens to be a continuation line too.  use fast Emacs 19
+	;; function if it's there.
+	(if (and (eq py-honor-comment-indentation nil)
+		 (fboundp 'forward-comment))
+	    (forward-comment (- (point-max)))
+	  (let ((prefix-re (concat py-block-comment-prefix &quot;[ \t]*&quot;))
+		done)
+	    (while (not done)
+	      (re-search-backward &quot;^[ \t]*\\([^ \t\n#]\\|#\\)&quot; nil 'move)
+	      (setq done (or (bobp)
+			     (and (eq py-honor-comment-indentation t)
+				  (save-excursion
+				    (back-to-indentation)
+				    (not (looking-at prefix-re))
+				    ))
+			     (and (not (eq py-honor-comment-indentation t))
+				  (save-excursion
+				    (back-to-indentation)
+				    (and (not (looking-at prefix-re))
+					 (or (looking-at &quot;[^#]&quot;)
+					     (not (zerop (current-column)))
+					     ))
+				    ))
+			     ))
+	      )))
+	;; if we landed inside a string, go to the beginning of that
+	;; string. this handles triple quoted, multi-line spanning
+	;; strings.
+	(py-goto-beginning-of-tqs (nth 3 (parse-partial-sexp bod (point))))
+	;; now skip backward over continued lines
+	(setq placeholder (point))
+	(py-goto-initial-line)
+	;; we may *now* have landed in a TQS, so find the beginning of
+	;; this string.
+	(py-goto-beginning-of-tqs
+	 (save-excursion (nth 3 (parse-partial-sexp
+				 placeholder (point)))))
+	(+ (current-indentation)
+	   (if (py-statement-opens-block-p)
+	       py-indent-offset
+	     (if (and honor-block-close-p (py-statement-closes-block-p))
+		 (- py-indent-offset)
+	       0)))
+	)))))
+
+(defun py-guess-indent-offset (&amp;optional global)
+  &quot;Guess a good value for, and change, `py-indent-offset'.
+
+By default, make a buffer-local copy of `py-indent-offset' with the
+new value, so that other Python buffers are not affected.  With
+\\[universal-argument] (programmatically, optional argument GLOBAL),
+change the global value of `py-indent-offset'.  This affects all
+Python buffers (that don't have their own buffer-local copy), both
+those currently existing and those created later in the Emacs session.
+
+Some people use a different value for `py-indent-offset' than you use.
+There's no excuse for such foolishness, but sometimes you have to deal
+with their ugly code anyway.  This function examines the file and sets
+`py-indent-offset' to what it thinks it was when they created the
+mess.
+
+Specifically, it searches forward from the statement containing point,
+looking for a line that opens a block of code.  `py-indent-offset' is
+set to the difference in indentation between that line and the Python
+statement following it.  If the search doesn't succeed going forward,
+it's tried again going backward.&quot;
+  (interactive &quot;P&quot;)			; raw prefix arg
+  (let (new-value
+	(start (point))
+	(restart (point))
+	(found nil)
+	colon-indent)
+    (py-goto-initial-line)
+    (while (not (or found (eobp)))
+      (when (and (re-search-forward &quot;:[ \t]*\\($\\|[#\\]\\)&quot; nil 'move)
+		 (not (py-in-literal restart)))
+	(setq restart (point))
+	(py-goto-initial-line)
+	(if (py-statement-opens-block-p)
+	    (setq found t)
+	  (goto-char restart))))
+    (unless found
+      (goto-char start)
+      (py-goto-initial-line)
+      (while (not (or found (bobp)))
+	(setq found (and
+		     (re-search-backward &quot;:[ \t]*\\($\\|[#\\]\\)&quot; nil 'move)
+		     (or (py-goto-initial-line) t) ; always true -- side effect
+		     (py-statement-opens-block-p)))))
+    (setq colon-indent (current-indentation)
+	  found (and found (zerop (py-next-statement 1)))
+	  new-value (- (current-indentation) colon-indent))
+    (goto-char start)
+    (if (not found)
+	(error &quot;Sorry, couldn't guess a value for py-indent-offset&quot;)
+      (funcall (if global 'kill-local-variable 'make-local-variable)
+	       'py-indent-offset)
+      (setq py-indent-offset new-value)
+      (or noninteractive
+	  (message &quot;%s value of py-indent-offset set to %d&quot;
+		   (if global &quot;Global&quot; &quot;Local&quot;)
+		   py-indent-offset)))
+    ))
+
+(defun py-comment-indent-function ()
+  &quot;Python version of `comment-indent-function'.&quot;
+  ;; This is required when filladapt is turned off.  Without it, when
+  ;; filladapt is not used, comments which start in column zero
+  ;; cascade one character to the right
+  (save-excursion
+    (beginning-of-line)
+    (let ((eol (py-point 'eol)))
+      (and comment-start-skip
+	   (re-search-forward comment-start-skip eol t)
+	   (setq eol (match-beginning 0)))
+      (goto-char eol)
+      (skip-chars-backward &quot; \t&quot;)
+      (max comment-column (+ (current-column) (if (bolp) 0 1)))
+      )))
+
+(defun py-narrow-to-defun (&amp;optional class)
+  &quot;Make text outside current defun invisible.
+The defun visible is the one that contains point or follows point.
+Optional CLASS is passed directly to `py-beginning-of-def-or-class'.&quot;
+  (interactive &quot;P&quot;)
+  (save-excursion
+    (widen)
+    (py-end-of-def-or-class class)
+    (let ((end (point)))
+      (py-beginning-of-def-or-class class)
+      (narrow-to-region (point) end))))
+
+
+(defun py-shift-region (start end count)
+  &quot;Indent lines from START to END by COUNT spaces.&quot;
+  (save-excursion
+    (goto-char end)
+    (beginning-of-line)
+    (setq end (point))
+    (goto-char start)
+    (beginning-of-line)
+    (setq start (point))
+    (indent-rigidly start end count)))
+
+(defun py-shift-region-left (start end &amp;optional count)
+  &quot;Shift region of Python code to the left.
+The lines from the line containing the start of the current region up
+to (but not including) the line containing the end of the region are
+shifted to the left, by `py-indent-offset' columns.
+
+If a prefix argument is given, the region is instead shifted by that
+many columns.  With no active region, dedent only the current line.
+You cannot dedent the region if any line is already at column zero.&quot;
+  (interactive
+   (let ((p (point))
+	 (m (mark))
+	 (arg current-prefix-arg))
+     (if m
+	 (list (min p m) (max p m) arg)
+       (list p (save-excursion (forward-line 1) (point)) arg))))
+  ;; if any line is at column zero, don't shift the region
+  (save-excursion
+    (goto-char start)
+    (while (&lt; (point) end)
+      (back-to-indentation)
+      (if (and (zerop (current-column))
+	       (not (looking-at &quot;\\s *$&quot;)))
+	  (error &quot;Region is at left edge&quot;))
+      (forward-line 1)))
+  (py-shift-region start end (- (prefix-numeric-value
+				 (or count py-indent-offset))))
+  (py-keep-region-active))
+
+(defun py-shift-region-right (start end &amp;optional count)
+  &quot;Shift region of Python code to the right.
+The lines from the line containing the start of the current region up
+to (but not including) the line containing the end of the region are
+shifted to the right, by `py-indent-offset' columns.
+
+If a prefix argument is given, the region is instead shifted by that
+many columns.  With no active region, indent only the current line.&quot;
+  (interactive
+   (let ((p (point))
+	 (m (mark))
+	 (arg current-prefix-arg))
+     (if m
+	 (list (min p m) (max p m) arg)
+       (list p (save-excursion (forward-line 1) (point)) arg))))
+  (py-shift-region start end (prefix-numeric-value
+			      (or count py-indent-offset)))
+  (py-keep-region-active))
+
+(defun py-indent-region (start end &amp;optional indent-offset)
+  &quot;Reindent a region of Python code.
+
+The lines from the line containing the start of the current region up
+to (but not including) the line containing the end of the region are
+reindented.  If the first line of the region has a non-whitespace
+character in the first column, the first line is left alone and the
+rest of the region is reindented with respect to it.  Else the entire
+region is reindented with respect to the (closest code or indenting
+comment) statement immediately preceding the region.
+
+This is useful when code blocks are moved or yanked, when enclosing
+control structures are introduced or removed, or to reformat code
+using a new value for the indentation offset.
+
+If a numeric prefix argument is given, it will be used as the value of
+the indentation offset.  Else the value of `py-indent-offset' will be
+used.
+
+Warning: The region must be consistently indented before this function
+is called!  This function does not compute proper indentation from
+scratch (that's impossible in Python), it merely adjusts the existing
+indentation to be correct in context.
+
+Warning: This function really has no idea what to do with
+non-indenting comment lines, and shifts them as if they were indenting
+comment lines.  Fixing this appears to require telepathy.
+
+Special cases: whitespace is deleted from blank lines; continuation
+lines are shifted by the same amount their initial line was shifted,
+in order to preserve their relative indentation with respect to their
+initial line; and comment lines beginning in column 1 are ignored.&quot;
+  (interactive &quot;*r\nP&quot;)			; region; raw prefix arg
+  (save-excursion
+    (goto-char end)   (beginning-of-line) (setq end (point-marker))
+    (goto-char start) (beginning-of-line)
+    (let ((py-indent-offset (prefix-numeric-value
+			     (or indent-offset py-indent-offset)))
+	  (indents '(-1))		; stack of active indent levels
+	  (target-column 0)		; column to which to indent
+	  (base-shifted-by 0)		; amount last base line was shifted
+	  (indent-base (if (looking-at &quot;[ \t\n]&quot;)
+			   (py-compute-indentation t)
+			 0))
+	  ci)
+      (while (&lt; (point) end)
+	(setq ci (current-indentation))
+	;; figure out appropriate target column
+	(cond
+	 ((or (eq (following-char) ?#)	; comment in column 1
+	      (looking-at &quot;[ \t]*$&quot;))	; entirely blank
+	  (setq target-column 0))
+	 ((py-continuation-line-p)	; shift relative to base line
+	  (setq target-column (+ ci base-shifted-by)))
+	 (t				; new base line
+	  (if (&gt; ci (car indents))	; going deeper; push it
+	      (setq indents (cons ci indents))
+	    ;; else we should have seen this indent before
+	    (setq indents (memq ci indents)) ; pop deeper indents
+	    (if (null indents)
+		(error &quot;Bad indentation in region, at line %d&quot;
+		       (save-restriction
+			 (widen)
+			 (1+ (count-lines 1 (point)))))))
+	  (setq target-column (+ indent-base
+				 (* py-indent-offset
+				    (- (length indents) 2))))
+	  (setq base-shifted-by (- target-column ci))))
+	;; shift as needed
+	(if (/= ci target-column)
+	    (progn
+	      (delete-horizontal-space)
+	      (indent-to target-column)))
+	(forward-line 1))))
+  (set-marker end nil))
+
+(defun py-comment-region (beg end &amp;optional arg)
+  &quot;Like `comment-region' but uses double hash (`#') comment starter.&quot;
+  (interactive &quot;r\nP&quot;)
+  (let ((comment-start py-block-comment-prefix))
+    (comment-region beg end arg)))
+
+
+;; Functions for moving point
+(defun py-previous-statement (count)
+  &quot;Go to the start of the COUNTth preceding Python statement.
+By default, goes to the previous statement.  If there is no such
+statement, goes to the first statement.  Return count of statements
+left to move.  `Statements' do not include blank, comment, or
+continuation lines.&quot;
+  (interactive &quot;p&quot;)			; numeric prefix arg
+  (if (&lt; count 0) (py-next-statement (- count))
+    (py-goto-initial-line)
+    (let (start)
+      (while (and
+	      (setq start (point))	; always true -- side effect
+	      (&gt; count 0)
+	      (zerop (forward-line -1))
+	      (py-goto-statement-at-or-above))
+	(setq count (1- count)))
+      (if (&gt; count 0) (goto-char start)))
+    count))
+
+(defun py-next-statement (count)
+  &quot;Go to the start of next Python statement.
+If the statement at point is the i'th Python statement, goes to the
+start of statement i+COUNT.  If there is no such statement, goes to the
+last statement.  Returns count of statements left to move.  `Statements'
+do not include blank, comment, or continuation lines.&quot;
+  (interactive &quot;p&quot;)			; numeric prefix arg
+  (if (&lt; count 0) (py-previous-statement (- count))
+    (beginning-of-line)
+    (let (start)
+      (while (and
+	      (setq start (point))	; always true -- side effect
+	      (&gt; count 0)
+	      (py-goto-statement-below))
+	(setq count (1- count)))
+      (if (&gt; count 0) (goto-char start)))
+    count))
+
+(defun py-goto-block-up (&amp;optional nomark)
+  &quot;Move up to start of current block.
+Go to the statement that starts the smallest enclosing block; roughly
+speaking, this will be the closest preceding statement that ends with a
+colon and is indented less than the statement you started on.  If
+successful, also sets the mark to the starting point.
+
+`\\[py-mark-block]' can be used afterward to mark the whole code
+block, if desired.
+
+If called from a program, the mark will not be set if optional argument
+NOMARK is not nil.&quot;
+  (interactive)
+  (let ((start (point))
+	(found nil)
+	initial-indent)
+    (py-goto-initial-line)
+    ;; if on blank or non-indenting comment line, use the preceding stmt
+    (if (looking-at &quot;[ \t]*\\($\\|#[^ \t\n]\\)&quot;)
+	(progn
+	  (py-goto-statement-at-or-above)
+	  (setq found (py-statement-opens-block-p))))
+    ;; search back for colon line indented less
+    (setq initial-indent (current-indentation))
+    (if (zerop initial-indent)
+	;; force fast exit
+	(goto-char (point-min)))
+    (while (not (or found (bobp)))
+      (setq found
+	    (and
+	     (re-search-backward &quot;:[ \t]*\\($\\|[#\\]\\)&quot; nil 'move)
+	     (or (py-goto-initial-line) t) ; always true -- side effect
+	     (&lt; (current-indentation) initial-indent)
+	     (py-statement-opens-block-p))))
+    (if found
+	(progn
+	  (or nomark (push-mark start))
+	  (back-to-indentation))
+      (goto-char start)
+      (error &quot;Enclosing block not found&quot;))))
+
+(defun py-beginning-of-def-or-class (&amp;optional class count)
+  &quot;Move point to start of `def' or `class'.
+
+Searches back for the closest preceding `def'.  If you supply a prefix
+arg, looks for a `class' instead.  The docs below assume the `def'
+case; just substitute `class' for `def' for the other case.
+Programmatically, if CLASS is `either', then moves to either `class'
+or `def'.
+
+When second optional argument is given programmatically, move to the
+COUNTth start of `def'.
+
+If point is in a `def' statement already, and after the `d', simply
+moves point to the start of the statement.
+
+Otherwise (i.e. when point is not in a `def' statement, or at or
+before the `d' of a `def' statement), searches for the closest
+preceding `def' statement, and leaves point at its start.  If no such
+statement can be found, leaves point at the start of the buffer.
+
+Returns t iff a `def' statement is found by these rules.
+
+Note that doing this command repeatedly will take you closer to the
+start of the buffer each time.
+
+To mark the current `def', see `\\[py-mark-def-or-class]'.&quot;
+  (interactive &quot;P&quot;)			; raw prefix arg
+  (setq count (or count 1))
+  (let ((at-or-before-p (&lt;= (current-column) (current-indentation)))
+	(start-of-line (goto-char (py-point 'bol)))
+	(start-of-stmt (goto-char (py-point 'bos)))
+	(start-re (cond ((eq class 'either) &quot;^[ \t]*\\(class\\|def\\)\\&gt;&quot;)
+			(class &quot;^[ \t]*class\\&gt;&quot;)
+			(t &quot;^[ \t]*def\\&gt;&quot;)))
+	)
+    ;; searching backward
+    (if (and (&lt; 0 count)
+	     (or (/= start-of-stmt start-of-line)
+		 (not at-or-before-p)))
+	(end-of-line))
+    ;; search forward
+    (if (and (&gt; 0 count)
+	     (zerop (current-column))
+	     (looking-at start-re))
+	(end-of-line))
+    (if (re-search-backward start-re nil 'move count)
+	(goto-char (match-beginning 0)))))
+
+;; Backwards compatibility
+(defalias 'beginning-of-python-def-or-class 'py-beginning-of-def-or-class)
+
+(defun py-end-of-def-or-class (&amp;optional class count)
+  &quot;Move point beyond end of `def' or `class' body.
+
+By default, looks for an appropriate `def'.  If you supply a prefix
+arg, looks for a `class' instead.  The docs below assume the `def'
+case; just substitute `class' for `def' for the other case.
+Programmatically, if CLASS is `either', then moves to either `class'
+or `def'.
+
+When second optional argument is given programmatically, move to the
+COUNTth end of `def'.
+
+If point is in a `def' statement already, this is the `def' we use.
+
+Else, if the `def' found by `\\[py-beginning-of-def-or-class]'
+contains the statement you started on, that's the `def' we use.
+
+Otherwise, we search forward for the closest following `def', and use that.
+
+If a `def' can be found by these rules, point is moved to the start of
+the line immediately following the `def' block, and the position of the
+start of the `def' is returned.
+
+Else point is moved to the end of the buffer, and nil is returned.
+
+Note that doing this command repeatedly will take you closer to the
+end of the buffer each time.
+
+To mark the current `def', see `\\[py-mark-def-or-class]'.&quot;
+  (interactive &quot;P&quot;)			; raw prefix arg
+  (if (and count (/= count 1))
+      (py-beginning-of-def-or-class (- 1 count)))
+  (let ((start (progn (py-goto-initial-line) (point)))
+	(which (cond ((eq class 'either) &quot;\\(class\\|def\\)&quot;)
+		     (class &quot;class&quot;)
+		     (t &quot;def&quot;)))
+	(state 'not-found))
+    ;; move point to start of appropriate def/class
+    (if (looking-at (concat &quot;[ \t]*&quot; which &quot;\\&gt;&quot;)) ; already on one
+	(setq state 'at-beginning)
+      ;; else see if py-beginning-of-def-or-class hits container
+      (if (and (py-beginning-of-def-or-class class)
+	       (progn (py-goto-beyond-block)
+		      (&gt; (point) start)))
+	  (setq state 'at-end)
+	;; else search forward
+	(goto-char start)
+	(if (re-search-forward (concat &quot;^[ \t]*&quot; which &quot;\\&gt;&quot;) nil 'move)
+	    (progn (setq state 'at-beginning)
+		   (beginning-of-line)))))
+    (cond
+     ((eq state 'at-beginning) (py-goto-beyond-block) t)
+     ((eq state 'at-end) t)
+     ((eq state 'not-found) nil)
+     (t (error &quot;Internal error in `py-end-of-def-or-class'&quot;)))))
+
+;; Backwards compabitility
+(defalias 'end-of-python-def-or-class 'py-end-of-def-or-class)
+
+
+;; Functions for marking regions
+(defun py-mark-block (&amp;optional extend just-move)
+  &quot;Mark following block of lines.  With prefix arg, mark structure.
+Easier to use than explain.  It sets the region to an `interesting'
+block of succeeding lines.  If point is on a blank line, it goes down to
+the next non-blank line.  That will be the start of the region.  The end
+of the region depends on the kind of line at the start:
+
+ - If a comment, the region will include all succeeding comment lines up
+   to (but not including) the next non-comment line (if any).
+
+ - Else if a prefix arg is given, and the line begins one of these
+   structures:
+
+     if elif else try except finally for while def class
+
+   the region will be set to the body of the structure, including
+   following blocks that `belong' to it, but excluding trailing blank
+   and comment lines.  E.g., if on a `try' statement, the `try' block
+   and all (if any) of the following `except' and `finally' blocks
+   that belong to the `try' structure will be in the region.  Ditto
+   for if/elif/else, for/else and while/else structures, and (a bit
+   degenerate, since they're always one-block structures) def and
+   class blocks.
+
+ - Else if no prefix argument is given, and the line begins a Python
+   block (see list above), and the block is not a `one-liner' (i.e.,
+   the statement ends with a colon, not with code), the region will
+   include all succeeding lines up to (but not including) the next
+   code statement (if any) that's indented no more than the starting
+   line, except that trailing blank and comment lines are excluded.
+   E.g., if the starting line begins a multi-statement `def'
+   structure, the region will be set to the full function definition,
+   but without any trailing `noise' lines.
+
+ - Else the region will include all succeeding lines up to (but not
+   including) the next blank line, or code or indenting-comment line
+   indented strictly less than the starting line.  Trailing indenting
+   comment lines are included in this case, but not trailing blank
+   lines.
+
+A msg identifying the location of the mark is displayed in the echo
+area; or do `\\[exchange-point-and-mark]' to flip down to the end.
+
+If called from a program, optional argument EXTEND plays the role of
+the prefix arg, and if optional argument JUST-MOVE is not nil, just
+moves to the end of the block (&amp; does not set mark or display a msg).&quot;
+  (interactive &quot;P&quot;)			; raw prefix arg
+  (py-goto-initial-line)
+  ;; skip over blank lines
+  (while (and
+	  (looking-at &quot;[ \t]*$&quot;)	; while blank line
+	  (not (eobp)))			; &amp; somewhere to go
+    (forward-line 1))
+  (if (eobp)
+      (error &quot;Hit end of buffer without finding a non-blank stmt&quot;))
+  (let ((initial-pos (point))
+	(initial-indent (current-indentation))
+	last-pos			; position of last stmt in region
+	(followers
+	 '((if elif else) (elif elif else) (else)
+	   (try except finally) (except except) (finally)
+	   (for else) (while else)
+	   (def) (class) ) )
+	first-symbol next-symbol)
+
+    (cond
+     ;; if comment line, suck up the following comment lines
+     ((looking-at &quot;[ \t]*#&quot;)
+      (re-search-forward &quot;^[ \t]*[^ \t#]&quot; nil 'move) ; look for non-comment
+      (re-search-backward &quot;^[ \t]*#&quot;)	; and back to last comment in block
+      (setq last-pos (point)))
+
+     ;; else if line is a block line and EXTEND given, suck up
+     ;; the whole structure
+     ((and extend
+	   (setq first-symbol (py-suck-up-first-keyword) )
+	   (assq first-symbol followers))
+      (while (and
+	      (or (py-goto-beyond-block) t) ; side effect
+	      (forward-line -1)		; side effect
+	      (setq last-pos (point))	; side effect
+	      (py-goto-statement-below)
+	      (= (current-indentation) initial-indent)
+	      (setq next-symbol (py-suck-up-first-keyword))
+	      (memq next-symbol (cdr (assq first-symbol followers))))
+	(setq first-symbol next-symbol)))
+
+     ;; else if line *opens* a block, search for next stmt indented &lt;=
+     ((py-statement-opens-block-p)
+      (while (and
+	      (setq last-pos (point))	; always true -- side effect
+	      (py-goto-statement-below)
+	      (&gt; (current-indentation) initial-indent)
+	      )))
+
+     ;; else plain code line; stop at next blank line, or stmt or
+     ;; indenting comment line indented &lt;
+     (t
+      (while (and
+	      (setq last-pos (point))	; always true -- side effect
+	      (or (py-goto-beyond-final-line) t)
+	      (not (looking-at &quot;[ \t]*$&quot;)) ; stop at blank line
+	      (or
+	       (&gt;= (current-indentation) initial-indent)
+	       (looking-at &quot;[ \t]*#[^ \t\n]&quot;))) ; ignore non-indenting #
+	nil)))
+
+    ;; skip to end of last stmt
+    (goto-char last-pos)
+    (py-goto-beyond-final-line)
+
+    ;; set mark &amp; display
+    (if just-move
+	()				; just return
+      (push-mark (point) 'no-msg)
+      (forward-line -1)
+      (message &quot;Mark set after: %s&quot; (py-suck-up-leading-text))
+      (goto-char initial-pos))))
+
+(defun py-mark-def-or-class (&amp;optional class)
+  &quot;Set region to body of def (or class, with prefix arg) enclosing point.
+Pushes the current mark, then point, on the mark ring (all language
+modes do this, but although it's handy it's never documented ...).
+
+In most Emacs language modes, this function bears at least a
+hallucinogenic resemblance to `\\[py-end-of-def-or-class]' and
+`\\[py-beginning-of-def-or-class]'.
+
+And in earlier versions of Python mode, all 3 were tightly connected.
+Turned out that was more confusing than useful: the `goto start' and
+`goto end' commands are usually used to search through a file, and
+people expect them to act a lot like `search backward' and `search
+forward' string-search commands.  But because Python `def' and `class'
+can nest to arbitrary levels, finding the smallest def containing
+point cannot be done via a simple backward search: the def containing
+point may not be the closest preceding def, or even the closest
+preceding def that's indented less.  The fancy algorithm required is
+appropriate for the usual uses of this `mark' command, but not for the
+`goto' variations.
+
+So the def marked by this command may not be the one either of the
+`goto' commands find: If point is on a blank or non-indenting comment
+line, moves back to start of the closest preceding code statement or
+indenting comment line.  If this is a `def' statement, that's the def
+we use.  Else searches for the smallest enclosing `def' block and uses
+that.  Else signals an error.
+
+When an enclosing def is found: The mark is left immediately beyond
+the last line of the def block.  Point is left at the start of the
+def, except that: if the def is preceded by a number of comment lines
+followed by (at most) one optional blank line, point is left at the
+start of the comments; else if the def is preceded by a blank line,
+point is left at its start.
+
+The intent is to mark the containing def/class and its associated
+documentation, to make moving and duplicating functions and classes
+pleasant.&quot;
+  (interactive &quot;P&quot;)			; raw prefix arg
+  (let ((start (point))
+	(which (cond ((eq class 'either) &quot;\\(class\\|def\\)&quot;)
+		     (class &quot;class&quot;)
+		     (t &quot;def&quot;))))
+    (push-mark start)
+    (if (not (py-go-up-tree-to-keyword which))
+	(progn (goto-char start)
+	       (error &quot;Enclosing %s not found&quot;
+		      (if (eq class 'either)
+			  &quot;def or class&quot;
+			which)))
+      ;; else enclosing def/class found
+      (setq start (point))
+      (py-goto-beyond-block)
+      (push-mark (point))
+      (goto-char start)
+      (if (zerop (forward-line -1))	; if there is a preceding line
+	  (progn
+	    (if (looking-at &quot;[ \t]*$&quot;)	; it's blank
+		(setq start (point))	; so reset start point
+	      (goto-char start))	; else try again
+	    (if (zerop (forward-line -1))
+		(if (looking-at &quot;[ \t]*#&quot;) ; a comment
+		    ;; look back for non-comment line
+		    ;; tricky: note that the regexp matches a blank
+		    ;; line, cuz \n is in the 2nd character class
+		    (and
+		     (re-search-backward &quot;^[ \t]*[^ \t#]&quot; nil 'move)
+		     (forward-line 1))
+		  ;; no comment, so go back
+		  (goto-char start)))))))
+  (exchange-point-and-mark)
+  (py-keep-region-active))
+
+;; ripped from cc-mode
+(defun py-forward-into-nomenclature (&amp;optional arg)
+  &quot;Move forward to end of a nomenclature section or word.
+With \\[universal-argument] (programmatically, optional argument ARG), 
+do it that many times.
+
+A `nomenclature' is a fancy way of saying AWordWithMixedCaseNotUnderscores.&quot;
+  (interactive &quot;p&quot;)
+  (let ((case-fold-search nil))
+    (if (&gt; arg 0)
+	(re-search-forward
+	 &quot;\\(\\W\\|[_]\\)*\\([A-Z]*[a-z0-9]*\\)&quot;
+	 (point-max) t arg)
+      (while (and (&lt; arg 0)
+		  (re-search-backward
+		   &quot;\\(\\W\\|[a-z0-9]\\)[A-Z]+\\|\\(\\W\\|[_]\\)\\w+&quot;
+		   (point-min) 0))
+	(forward-char 1)
+	(setq arg (1+ arg)))))
+  (py-keep-region-active))
+
+(defun py-backward-into-nomenclature (&amp;optional arg)
+  &quot;Move backward to beginning of a nomenclature section or word.
+With optional ARG, move that many times.  If ARG is negative, move
+forward.
+
+A `nomenclature' is a fancy way of saying AWordWithMixedCaseNotUnderscores.&quot;
+  (interactive &quot;p&quot;)
+  (py-forward-into-nomenclature (- arg))
+  (py-keep-region-active))
+
+
+
+;; pdbtrack functions
+(defun py-pdbtrack-toggle-stack-tracking (arg)
+  (interactive &quot;P&quot;)
+  (if (not (get-buffer-process (current-buffer)))
+      (error &quot;No process associated with buffer '%s'&quot; (current-buffer)))
+  ;; missing or 0 is toggle, &gt;0 turn on, &lt;0 turn off
+  (if (or (not arg)
+	  (zerop (setq arg (prefix-numeric-value arg))))
+      (setq py-pdbtrack-do-tracking-p (not py-pdbtrack-do-tracking-p))
+    (setq py-pdbtrack-do-tracking-p (&gt; arg 0)))
+  (message &quot;%sabled Python's pdbtrack&quot;
+           (if py-pdbtrack-do-tracking-p &quot;En&quot; &quot;Dis&quot;)))
+
+(defun turn-on-pdbtrack ()
+  (interactive)
+  (py-pdbtrack-toggle-stack-tracking 1))
+
+(defun turn-off-pdbtrack ()
+  (interactive)
+  (py-pdbtrack-toggle-stack-tracking 0))
+
+
+
+;; Pychecker
+(defun py-pychecker-run (command)
+  &quot;*Run pychecker (default on the file currently visited).&quot;
+  (interactive
+   (let ((default
+           (format &quot;%s %s %s&quot; py-pychecker-command
+		   (mapconcat 'identity py-pychecker-command-args &quot; &quot;)
+		   (buffer-file-name)))
+	 (last (when py-pychecker-history
+		 (let* ((lastcmd (car py-pychecker-history))
+			(cmd (cdr (reverse (split-string lastcmd))))
+			(newcmd (reverse (cons (buffer-file-name) cmd))))
+		   (mapconcat 'identity newcmd &quot; &quot;)))))
+
+     (list
+      (if (fboundp 'read-shell-command)
+	  (read-shell-command &quot;Run pychecker like this: &quot;
+			      (if last
+				  last
+				default)
+			      'py-pychecker-history)
+	(read-string &quot;Run pychecker like this: &quot;
+		     (if last
+			 last
+		       default)
+		     'py-pychecker-history))
+	)))
+  (save-some-buffers (not py-ask-about-save) nil)
+  (compile-internal command &quot;No more errors&quot;))
+
+
+
+;; pydoc commands. The guts of this function is stolen from XEmacs's
+;; symbol-near-point, but without the useless regexp-quote call on the
+;; results, nor the interactive bit.  Also, we've added the temporary
+;; syntax table setting, which Skip originally had broken out into a
+;; separate function.  Note that Emacs doesn't have the original
+;; function.
+(defun py-symbol-near-point ()
+  &quot;Return the first textual item to the nearest point.&quot;
+  ;; alg stolen from etag.el
+  (save-excursion
+    (with-syntax-table py-dotted-expression-syntax-table
+      (if (or (bobp) (not (memq (char-syntax (char-before)) '(?w ?_))))
+	  (while (not (looking-at &quot;\\sw\\|\\s_\\|\\'&quot;))
+	    (forward-char 1)))
+      (while (looking-at &quot;\\sw\\|\\s_&quot;)
+	(forward-char 1))
+      (if (re-search-backward &quot;\\sw\\|\\s_&quot; nil t)
+	  (progn (forward-char 1)
+		 (buffer-substring (point)
+				   (progn (forward-sexp -1)
+					  (while (looking-at &quot;\\s'&quot;)
+					    (forward-char 1))
+					  (point))))
+	nil))))
+
+(defun py-help-at-point ()
+  &quot;Get help from Python based on the symbol nearest point.&quot;
+  (interactive)
+  (let* ((sym (py-symbol-near-point))
+	 (base (substring sym 0 (or (search &quot;.&quot; sym :from-end t) 0)))
+	 cmd)
+    (if (not (equal base &quot;&quot;))
+        (setq cmd (concat &quot;import &quot; base &quot;\n&quot;)))
+    (setq cmd (concat &quot;import pydoc\n&quot;
+                      cmd
+		      &quot;try: pydoc.help('&quot; sym &quot;')\n&quot;
+		      &quot;except: print 'No help available on:', \&quot;&quot; sym &quot;\&quot;&quot;))
+    (message cmd)
+    (py-execute-string cmd)
+    (set-buffer &quot;*Python Output*&quot;)
+    ;; BAW: Should we really be leaving the output buffer in help-mode?
+    (help-mode)))
+
+
+
+;; Documentation functions
+
+;; dump the long form of the mode blurb; does the usual doc escapes,
+;; plus lines of the form ^[vc]:name$ to suck variable &amp; command docs
+;; out of the right places, along with the keys they're on &amp; current
+;; values
+(defun py-dump-help-string (str)
+  (with-output-to-temp-buffer &quot;*Help*&quot;
+    (let ((locals (buffer-local-variables))
+	  funckind funcname func funcdoc
+	  (start 0) mstart end
+	  keys )
+      (while (string-match &quot;^%\\([vc]\\):\\(.+\\)\n&quot; str start)
+	(setq mstart (match-beginning 0)  end (match-end 0)
+	      funckind (substring str (match-beginning 1) (match-end 1))
+	      funcname (substring str (match-beginning 2) (match-end 2))
+	      func (intern funcname))
+	(princ (substitute-command-keys (substring str start mstart)))
+	(cond
+	 ((equal funckind &quot;c&quot;)		; command
+	  (setq funcdoc (documentation func)
+		keys (concat
+		      &quot;Key(s): &quot;
+		      (mapconcat 'key-description
+				 (where-is-internal func py-mode-map)
+				 &quot;, &quot;))))
+	 ((equal funckind &quot;v&quot;)		; variable
+	  (setq funcdoc (documentation-property func 'variable-documentation)
+		keys (if (assq func locals)
+			 (concat
+			  &quot;Local/Global values: &quot;
+			  (prin1-to-string (symbol-value func))
+			  &quot; / &quot;
+			  (prin1-to-string (default-value func)))
+		       (concat
+			&quot;Value: &quot;
+			(prin1-to-string (symbol-value func))))))
+	 (t				; unexpected
+	  (error &quot;Error in py-dump-help-string, tag `%s'&quot; funckind)))
+	(princ (format &quot;\n-&gt; %s:\t%s\t%s\n\n&quot;
+		       (if (equal funckind &quot;c&quot;) &quot;Command&quot; &quot;Variable&quot;)
+		       funcname keys))
+	(princ funcdoc)
+	(terpri)
+	(setq start end))
+      (princ (substitute-command-keys (substring str start))))
+    (print-help-return-message)))
+
+(defun py-describe-mode ()
+  &quot;Dump long form of Python-mode docs.&quot;
+  (interactive)
+  (py-dump-help-string &quot;Major mode for editing Python files.
+Knows about Python indentation, tokens, comments and continuation lines.
+Paragraphs are separated by blank lines only.
+
+Major sections below begin with the string `@'; specific function and
+variable docs begin with `-&gt;'.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">+ at EXECUTING</A> PYTHON CODE
+
+\\[py-execute-import-or-reload]\timports or reloads the file in the Python interpreter
+\\[py-execute-buffer]\tsends the entire buffer to the Python interpreter
+\\[py-execute-region]\tsends the current region
+\\[py-execute-def-or-class]\tsends the current function or class definition
+\\[py-execute-string]\tsends an arbitrary string
+\\[py-shell]\tstarts a Python interpreter window; this will be used by
+\tsubsequent Python execution commands
+%c:py-execute-import-or-reload
+%c:py-execute-buffer
+%c:py-execute-region
+%c:py-execute-def-or-class
+%c:py-execute-string
+%c:py-shell
+
<A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">+ at VARIABLES</A>
+
+py-indent-offset\tindentation increment
+py-block-comment-prefix\tcomment string used by comment-region
+
+py-python-command\tshell command to invoke Python interpreter
+py-temp-directory\tdirectory used for temp files (if needed)
+
+py-beep-if-tab-change\tring the bell if tab-width is changed
+%v:py-indent-offset
+%v:py-block-comment-prefix
+%v:py-python-command
+%v:py-temp-directory
+%v:py-beep-if-tab-change
+
<A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">+ at KINDS</A> OF LINES
+
+Each physical line in the file is either a `continuation line' (the
+preceding line ends with a backslash that's not part of a comment, or
+the paren/bracket/brace nesting level at the start of the line is
+non-zero, or both) or an `initial line' (everything else).
+
+An initial line is in turn a `blank line' (contains nothing except
+possibly blanks or tabs), a `comment line' (leftmost non-blank
+character is `#'), or a `code line' (everything else).
+
+Comment Lines
+
+Although all comment lines are treated alike by Python, Python mode
+recognizes two kinds that act differently with respect to indentation.
+
+An `indenting comment line' is a comment line with a blank, tab or
+nothing after the initial `#'.  The indentation commands (see below)
+treat these exactly as if they were code lines: a line following an
+indenting comment line will be indented like the comment line.  All
+other comment lines (those with a non-whitespace character immediately
+following the initial `#') are `non-indenting comment lines', and
+their indentation is ignored by the indentation commands.
+
+Indenting comment lines are by far the usual case, and should be used
+whenever possible.  Non-indenting comment lines are useful in cases
+like these:
+
+\ta = b   # a very wordy single-line comment that ends up being
+\t        #... continued onto another line
+
+\tif a == b:
+##\t\tprint 'panic!' # old code we've `commented out'
+\t\treturn a
+
+Since the `#...' and `##' comment lines have a non-whitespace
+character following the initial `#', Python mode ignores them when
+computing the proper indentation for the next line.
+
+Continuation Lines and Statements
+
+The Python-mode commands generally work on statements instead of on
+individual lines, where a `statement' is a comment or blank line, or a
+code line and all of its following continuation lines (if any)
+considered as a single logical unit.  The commands in this mode
+generally (when it makes sense) automatically move to the start of the
+statement containing point, even if point happens to be in the middle
+of some continuation line.
+
+
<A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">+ at INDENTATION</A>
+
+Primarily for entering new code:
+\t\\[indent-for-tab-command]\t indent line appropriately
+\t\\[py-newline-and-indent]\t insert newline, then indent
+\t\\[py-electric-backspace]\t reduce indentation, or delete single character
+
+Primarily for reindenting existing code:
+\t\\[py-guess-indent-offset]\t guess py-indent-offset from file content; change locally
+\t\\[universal-argument] \\[py-guess-indent-offset]\t ditto, but change globally
+
+\t\\[py-indent-region]\t reindent region to match its context
+\t\\[py-shift-region-left]\t shift region left by py-indent-offset
+\t\\[py-shift-region-right]\t shift region right by py-indent-offset
+
+Unlike most programming languages, Python uses indentation, and only
+indentation, to specify block structure.  Hence the indentation supplied
+automatically by Python-mode is just an educated guess:  only you know
+the block structure you intend, so only you can supply correct
+indentation.
+
+The \\[indent-for-tab-command] and \\[py-newline-and-indent] keys try to suggest plausible indentation, based on
+the indentation of preceding statements.  E.g., assuming
+py-indent-offset is 4, after you enter
+\tif a &gt; 0: \\[py-newline-and-indent]
+the cursor will be moved to the position of the `_' (_ is not a
+character in the file, it's just used here to indicate the location of
+the cursor):
+\tif a &gt; 0:
+\t    _
+If you then enter `c = d' \\[py-newline-and-indent], the cursor will move
+to
+\tif a &gt; 0:
+\t    c = d
+\t    _
+Python-mode cannot know whether that's what you intended, or whether
+\tif a &gt; 0:
+\t    c = d
+\t_
+was your intent.  In general, Python-mode either reproduces the
+indentation of the (closest code or indenting-comment) preceding
+statement, or adds an extra py-indent-offset blanks if the preceding
+statement has `:' as its last significant (non-whitespace and non-
+comment) character.  If the suggested indentation is too much, use
+\\[py-electric-backspace] to reduce it.
+
+Continuation lines are given extra indentation.  If you don't like the
+suggested indentation, change it to something you do like, and Python-
+mode will strive to indent later lines of the statement in the same way.
+
+If a line is a continuation line by virtue of being in an unclosed
+paren/bracket/brace structure (`list', for short), the suggested
+indentation depends on whether the current line contains the first item
+in the list.  If it does, it's indented py-indent-offset columns beyond
+the indentation of the line containing the open bracket.  If you don't
+like that, change it by hand.  The remaining items in the list will mimic
+whatever indentation you give to the first item.
+
+If a line is a continuation line because the line preceding it ends with
+a backslash, the third and following lines of the statement inherit their
+indentation from the line preceding them.  The indentation of the second
+line in the statement depends on the form of the first (base) line:  if
+the base line is an assignment statement with anything more interesting
+than the backslash following the leftmost assigning `=', the second line
+is indented two columns beyond that `='.  Else it's indented to two
+columns beyond the leftmost solid chunk of non-whitespace characters on
+the base line.
+
+Warning:  indent-region should not normally be used!  It calls \\[indent-for-tab-command]
+repeatedly, and as explained above, \\[indent-for-tab-command] can't guess the block
+structure you intend.
+%c:indent-for-tab-command
+%c:py-newline-and-indent
+%c:py-electric-backspace
+
+
+The next function may be handy when editing code you didn't write:
+%c:py-guess-indent-offset
+
+
+The remaining `indent' functions apply to a region of Python code.  They
+assume the block structure (equals indentation, in Python) of the region
+is correct, and alter the indentation in various ways while preserving
+the block structure:
+%c:py-indent-region
+%c:py-shift-region-left
+%c:py-shift-region-right
+
<A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">+ at MARKING</A> &amp; MANIPULATING REGIONS OF CODE
+
+\\[py-mark-block]\t mark block of lines
+\\[py-mark-def-or-class]\t mark smallest enclosing def
+\\[universal-argument] \\[py-mark-def-or-class]\t mark smallest enclosing class
+\\[comment-region]\t comment out region of code
+\\[universal-argument] \\[comment-region]\t uncomment region of code
+%c:py-mark-block
+%c:py-mark-def-or-class
+%c:comment-region
+
<A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">+ at MOVING</A> POINT
+
+\\[py-previous-statement]\t move to statement preceding point
+\\[py-next-statement]\t move to statement following point
+\\[py-goto-block-up]\t move up to start of current block
+\\[py-beginning-of-def-or-class]\t move to start of def
+\\[universal-argument] \\[py-beginning-of-def-or-class]\t move to start of class
+\\[py-end-of-def-or-class]\t move to end of def
+\\[universal-argument] \\[py-end-of-def-or-class]\t move to end of class
+
+The first two move to one statement beyond the statement that contains
+point.  A numeric prefix argument tells them to move that many
+statements instead.  Blank lines, comment lines, and continuation lines
+do not count as `statements' for these commands.  So, e.g., you can go
+to the first code statement in a file by entering
+\t\\[beginning-of-buffer]\t to move to the top of the file
+\t\\[py-next-statement]\t to skip over initial comments and blank lines
+Or do `\\[py-previous-statement]' with a huge prefix argument.
+%c:py-previous-statement
+%c:py-next-statement
+%c:py-goto-block-up
+%c:py-beginning-of-def-or-class
+%c:py-end-of-def-or-class
+
<A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">+ at LITTLE-KNOWN</A> EMACS COMMANDS PARTICULARLY USEFUL IN PYTHON MODE
+
+`\\[indent-new-comment-line]' is handy for entering a multi-line comment.
+
+`\\[set-selective-display]' with a `small' prefix arg is ideally suited for viewing the
+overall class and def structure of a module.
+
+`\\[back-to-indentation]' moves point to a line's first non-blank character.
+
+`\\[indent-relative]' is handy for creating odd indentation.
+
<A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">+ at OTHER</A> EMACS HINTS
+
+If you don't like the default value of a variable, change its value to
+whatever you do like by putting a `setq' line in your .emacs file.
+E.g., to set the indentation increment to 4, put this line in your
+.emacs:
+\t(setq  py-indent-offset  4)
+To see the value of a variable, do `\\[describe-variable]' and enter the variable
+name at the prompt.
+
+When entering a key sequence like `C-c C-n', it is not necessary to
+release the CONTROL key after doing the `C-c' part -- it suffices to
+press the CONTROL key, press and release `c' (while still holding down
+CONTROL), press and release `n' (while still holding down CONTROL), &amp;
+then release CONTROL.
+
+Entering Python mode calls with no arguments the value of the variable
+`python-mode-hook', if that value exists and is not nil; for backward
+compatibility it also tries `py-mode-hook'; see the `Hooks' section of
+the Elisp manual for details.
+
+Obscure:  When python-mode is first loaded, it looks for all bindings
+to newline-and-indent in the global keymap, and shadows them with
+local bindings to py-newline-and-indent.&quot;))
+
+(require 'info-look)
+;; The info-look package does not always provide this function (it
+;; appears this is the case with XEmacs 21.1)
+(when (fboundp 'info-lookup-maybe-add-help)
+  (info-lookup-maybe-add-help
+   :mode 'python-mode
+   :regexp &quot;[a-zA-Z0-9_]+&quot;
+   :doc-spec '((&quot;(python-lib)Module Index&quot;)
+	       (&quot;(python-lib)Class-Exception-Object Index&quot;)
+	       (&quot;(python-lib)Function-Method-Variable Index&quot;)
+	       (&quot;(python-lib)Miscellaneous Index&quot;)))
+  )
+
+
+;; Helper functions
+(defvar py-parse-state-re
+  (concat
+   &quot;^[ \t]*\\(elif\\|else\\|while\\|def\\|class\\)\\&gt;&quot;
+   &quot;\\|&quot;
+   &quot;^[^ #\t\n]&quot;))
+
+(defun py-parse-state ()
+  &quot;Return the parse state at point (see `parse-partial-sexp' docs).&quot;
+  (save-excursion
+    (let ((here (point))
+	  pps done)
+      (while (not done)
+	;; back up to the first preceding line (if any; else start of
+	;; buffer) that begins with a popular Python keyword, or a
+	;; non- whitespace and non-comment character.  These are good
+	;; places to start parsing to see whether where we started is
+	;; at a non-zero nesting level.  It may be slow for people who
+	;; write huge code blocks or huge lists ... tough beans.
+	(re-search-backward py-parse-state-re nil 'move)
+	(beginning-of-line)
+	;; In XEmacs, we have a much better way to test for whether
+	;; we're in a triple-quoted string or not.  Emacs does not
+	;; have this built-in function, which is its loss because
+	;; without scanning from the beginning of the buffer, there's
+	;; no accurate way to determine this otherwise.
+	(save-excursion (setq pps (parse-partial-sexp (point) here)))
+	;; make sure we don't land inside a triple-quoted string
+	(setq done (or (not (nth 3 pps))
+		       (bobp)))
+	;; Just go ahead and short circuit the test back to the
+	;; beginning of the buffer.  This will be slow, but not
+	;; nearly as slow as looping through many
+	;; re-search-backwards.
+	(if (not done)
+	    (goto-char (point-min))))
+      pps)))
+
+(defun py-nesting-level ()
+  &quot;Return the buffer position of the last unclosed enclosing list.
+If nesting level is zero, return nil.&quot;
+  (let ((status (py-parse-state)))
+    (if (zerop (car status))
+	nil				; not in a nest
+      (car (cdr status)))))		; char# of open bracket
+
+(defun py-backslash-continuation-line-p ()
+  &quot;Return t iff preceding line ends with backslash that is not in a comment.&quot;
+  (save-excursion
+    (beginning-of-line)
+    (and
+     ;; use a cheap test first to avoid the regexp if possible
+     ;; use 'eq' because char-after may return nil
+     (eq (char-after (- (point) 2)) ?\\ )
+     ;; make sure; since eq test passed, there is a preceding line
+     (forward-line -1)			; always true -- side effect
+     (looking-at py-continued-re))))
+
+(defun py-continuation-line-p ()
+  &quot;Return t iff current line is a continuation line.&quot;
+  (save-excursion
+    (beginning-of-line)
+    (or (py-backslash-continuation-line-p)
+	(py-nesting-level))))
+
+(defun py-goto-beginning-of-tqs (delim)
+  &quot;Go to the beginning of the triple quoted string we find ourselves in.
+DELIM is the TQS string delimiter character we're searching backwards
+for.&quot;
+  (let ((skip (and delim (make-string 1 delim)))
+	(continue t))
+    (when skip
+      (save-excursion
+	(while continue
+	  (py-safe (search-backward skip))
+	  (setq continue (and (not (bobp))
+			      (= (char-before) ?\\))))
+	(if (and (= (char-before) delim)
+		 (= (char-before (1- (point))) delim))
+	    (setq skip (make-string 3 delim))))
+      ;; we're looking at a triple-quoted string
+      (py-safe (search-backward skip)))))
+
+(defun py-goto-initial-line ()
+  &quot;Go to the initial line of the current statement.
+Usually this is the line we're on, but if we're on the 2nd or
+following lines of a continuation block, we need to go up to the first
+line of the block.&quot;
+  ;; Tricky: We want to avoid quadratic-time behavior for long
+  ;; continued blocks, whether of the backslash or open-bracket
+  ;; varieties, or a mix of the two.  The following manages to do that
+  ;; in the usual cases.
+  ;;
+  ;; Also, if we're sitting inside a triple quoted string, this will
+  ;; drop us at the line that begins the string.
+  (let (open-bracket-pos)
+    (while (py-continuation-line-p)
+      (beginning-of-line)
+      (if (py-backslash-continuation-line-p)
+	  (while (py-backslash-continuation-line-p)
+	    (forward-line -1))
+	;; else zip out of nested brackets/braces/parens
+	(while (setq open-bracket-pos (py-nesting-level))
+	  (goto-char open-bracket-pos)))))
+  (beginning-of-line))
+
+(defun py-goto-beyond-final-line ()
+  &quot;Go to the point just beyond the fine line of the current statement.
+Usually this is the start of the next line, but if this is a
+multi-line statement we need to skip over the continuation lines.&quot;
+  ;; Tricky: Again we need to be clever to avoid quadratic time
+  ;; behavior.
+  ;;
+  ;; XXX: Not quite the right solution, but deals with multi-line doc
+  ;; strings
+  (if (looking-at (concat &quot;[ \t]*\\(&quot; py-stringlit-re &quot;\\)&quot;))
+      (goto-char (match-end 0)))
+  ;;
+  (forward-line 1)
+  (let (state)
+    (while (and (py-continuation-line-p)
+		(not (eobp)))
+      ;; skip over the backslash flavor
+      (while (and (py-backslash-continuation-line-p)
+		  (not (eobp)))
+	(forward-line 1))
+      ;; if in nest, zip to the end of the nest
+      (setq state (py-parse-state))
+      (if (and (not (zerop (car state)))
+	       (not (eobp)))
+	  (progn
+	    (parse-partial-sexp (point) (point-max) 0 nil state)
+	    (forward-line 1))))))
+
+(defun py-statement-opens-block-p ()
+  &quot;Return t iff the current statement opens a block.
+I.e., iff it ends with a colon that is not in a comment.  Point should 
+be at the start of a statement.&quot;
+  (save-excursion
+    (let ((start (point))
+	  (finish (progn (py-goto-beyond-final-line) (1- (point))))
+	  (searching t)
+	  (answer nil)
+	  state)
+      (goto-char start)
+      (while searching
+	;; look for a colon with nothing after it except whitespace, and
+	;; maybe a comment
+	(if (re-search-forward &quot;:\\([ \t]\\|\\\\\n\\)*\\(#.*\\)?$&quot;
+			       finish t)
+	    (if (eq (point) finish)	; note: no `else' clause; just
+					; keep searching if we're not at
+					; the end yet
+		;; sure looks like it opens a block -- but it might
+		;; be in a comment
+		(progn
+		  (setq searching nil)	; search is done either way
+		  (setq state (parse-partial-sexp start
+						  (match-beginning 0)))
+		  (setq answer (not (nth 4 state)))))
+	  ;; search failed: couldn't find another interesting colon
+	  (setq searching nil)))
+      answer)))
+
+(defun py-statement-closes-block-p ()
+  &quot;Return t iff the current statement closes a block.
+I.e., if the line starts with `return', `raise', `break', `continue',
+and `pass'.  This doesn't catch embedded statements.&quot;
+  (let ((here (point)))
+    (py-goto-initial-line)
+    (back-to-indentation)
+    (prog1
+	(looking-at (concat py-block-closing-keywords-re &quot;\\&gt;&quot;))
+      (goto-char here))))
+
+(defun py-goto-beyond-block ()
+  &quot;Go to point just beyond the final line of block begun by the current line.
+This is the same as where `py-goto-beyond-final-line' goes unless
+we're on colon line, in which case we go to the end of the block.
+Assumes point is at the beginning of the line.&quot;
+  (if (py-statement-opens-block-p)
+      (py-mark-block nil 'just-move)
+    (py-goto-beyond-final-line)))
+
+(defun py-goto-statement-at-or-above ()
+  &quot;Go to the start of the first statement at or preceding point.
+Return t if there is such a statement, otherwise nil.  `Statement'
+does not include blank lines, comments, or continuation lines.&quot;
+  (py-goto-initial-line)
+  (if (looking-at py-blank-or-comment-re)
+      ;; skip back over blank &amp; comment lines
+      ;; note:  will skip a blank or comment line that happens to be
+      ;; a continuation line too
+      (if (re-search-backward &quot;^[ \t]*[^ \t#\n]&quot; nil t)
+	  (progn (py-goto-initial-line) t)
+	nil)
+    t))
+
+(defun py-goto-statement-below ()
+  &quot;Go to start of the first statement following the statement containing point.
+Return t if there is such a statement, otherwise nil.  `Statement'
+does not include blank lines, comments, or continuation lines.&quot;
+  (beginning-of-line)
+  (let ((start (point)))
+    (py-goto-beyond-final-line)
+    (while (and
+	    (or (looking-at py-blank-or-comment-re)
+		(py-in-literal))
+	    (not (eobp)))
+      (forward-line 1))
+    (if (eobp)
+	(progn (goto-char start) nil)
+      t)))
+
+(defun py-go-up-tree-to-keyword (key)
+  &quot;Go to begining of statement starting with KEY, at or preceding point.
+
+KEY is a regular expression describing a Python keyword.  Skip blank
+lines and non-indenting comments.  If the statement found starts with
+KEY, then stop, otherwise go back to first enclosing block starting
+with KEY.  If successful, leave point at the start of the KEY line and 
+return t.  Otherwise, leav point at an undefined place and return nil.&quot;
+  ;; skip blanks and non-indenting #
+  (py-goto-initial-line)
+  (while (and
+	  (looking-at &quot;[ \t]*\\($\\|#[^ \t\n]\\)&quot;)
+	  (zerop (forward-line -1)))	; go back
+    nil)
+  (py-goto-initial-line)
+  (let* ((re (concat &quot;[ \t]*&quot; key &quot;\\b&quot;))
+	 (case-fold-search nil)		; let* so looking-at sees this
+	 (found (looking-at re))
+	 (dead nil))
+    (while (not (or found dead))
+      (condition-case nil		; in case no enclosing block
+	  (py-goto-block-up 'no-mark)
+	(error (setq dead t)))
+      (or dead (setq found (looking-at re))))
+    (beginning-of-line)
+    found))
+
+(defun py-suck-up-leading-text ()
+  &quot;Return string in buffer from start of indentation to end of line.
+Prefix with \&quot;...\&quot; if leading whitespace was skipped.&quot;
+  (save-excursion
+    (back-to-indentation)
+    (concat
+     (if (bolp) &quot;&quot; &quot;...&quot;)
+     (buffer-substring (point) (progn (end-of-line) (point))))))
+
+(defun py-suck-up-first-keyword ()
+  &quot;Return first keyword on the line as a Lisp symbol.
+`Keyword' is defined (essentially) as the regular expression
+([a-z]+).  Returns nil if none was found.&quot;
+  (let ((case-fold-search nil))
+    (if (looking-at &quot;[ \t]*\\([a-z]+\\)\\b&quot;)
+	(intern (buffer-substring (match-beginning 1) (match-end 1)))
+      nil)))
+
+(defun py-current-defun ()
+  &quot;Python value for `add-log-current-defun-function'.
+This tells add-log.el how to find the current function/method/variable.&quot;
+  (save-excursion
+
+    ;; Move back to start of the current statement.
+
+    (py-goto-initial-line)
+    (back-to-indentation)
+    (while (and (or (looking-at py-blank-or-comment-re)
+		    (py-in-literal))
+		(not (bobp)))
+      (backward-to-indentation 1))
+    (py-goto-initial-line)
+
+    (let ((scopes &quot;&quot;)
+	  (sep &quot;&quot;)
+	  dead assignment)
+
+      ;; Check for an assignment.  If this assignment exists inside a
+      ;; def, it will be overwritten inside the while loop.  If it
+      ;; exists at top lever or inside a class, it will be preserved.
+
+      (when (looking-at &quot;[ \t]*\\([a-zA-Z0-9_]+\\)[ \t]*=&quot;)
+	(setq scopes (buffer-substring (match-beginning 1) (match-end 1)))
+	(setq assignment t)
+	(setq sep &quot;.&quot;))
+
+      ;; Prepend the name of each outer socpe (def or class).
+
+      (while (not dead)
+	(if (and (py-go-up-tree-to-keyword &quot;\\(class\\|def\\)&quot;)
+		 (looking-at
+		  &quot;[ \t]*\\(class\\|def\\)[ \t]*\\([a-zA-Z0-9_]+\\)[ \t]*&quot;))
+	    (let ((name (buffer-substring (match-beginning 2) (match-end 2))))
+	      (if (and assignment (looking-at &quot;[ \t]*def&quot;))
+		  (setq scopes name)
+		(setq scopes (concat name sep scopes))
+		(setq sep &quot;.&quot;))))
+	(setq assignment nil)
+	(condition-case nil		; Terminate nicely at top level.
+	    (py-goto-block-up 'no-mark)
+	  (error (setq dead t))))
+      (if (string= scopes &quot;&quot;)
+	  nil
+	scopes))))
+
+
+
+(defconst py-help-address &quot;<A HREF="https://lists.berlios.de/mailman/listinfo/gappy-svn">python-mode at python.org</A>&quot;
+  &quot;Address accepting submission of bug reports.&quot;)
+
+(defun py-version ()
+  &quot;Echo the current version of `python-mode' in the minibuffer.&quot;
+  (interactive)
+  (message &quot;Using `python-mode' version %s&quot; py-version)
+  (py-keep-region-active))
+
+;; only works under Emacs 19
+;(eval-when-compile
+;  (require 'reporter))
+
+(defun py-submit-bug-report (enhancement-p)
+  &quot;Submit via mail a bug report on `python-mode'.
+With \\[universal-argument] (programmatically, argument ENHANCEMENT-P
+non-nil) just submit an enhancement request.&quot;
+  (interactive
+   (list (not (y-or-n-p
+	       &quot;Is this a bug report (hit `n' to send other comments)? &quot;))))
+  (let ((reporter-prompt-for-summary-p (if enhancement-p
+					   &quot;(Very) brief summary: &quot;
+					 t)))
+    (require 'reporter)
+    (reporter-submit-bug-report
+     py-help-address			;address
+     (concat &quot;python-mode &quot; py-version)	;pkgname
+     ;; varlist
+     (if enhancement-p nil
+       '(py-python-command
+	 py-indent-offset
+	 py-block-comment-prefix
+	 py-temp-directory
+	 py-beep-if-tab-change))
+     nil				;pre-hooks
+     nil				;post-hooks
+     &quot;Dear Barry,&quot;)			;salutation
+    (if enhancement-p nil
+      (set-mark (point))
+      (insert 
+&quot;Please replace this text with a sufficiently large code sample\n\
+and an exact recipe so that I can reproduce your problem.  Failure\n\
+to do so may mean a greater delay in fixing your bug.\n\n&quot;)
+      (exchange-point-and-mark)
+      (py-keep-region-active))))
+
+
+(defun py-kill-emacs-hook ()
+  &quot;Delete files in `py-file-queue'.
+These are Python temporary files awaiting execution.&quot;
+  (mapcar #'(lambda (filename)
+	      (py-safe (delete-file filename)))
+	  py-file-queue))
+
+;; arrange to kill temp files when Emacs exists
+(add-hook 'kill-emacs-hook 'py-kill-emacs-hook)
+(add-hook 'comint-output-filter-functions 'py-pdbtrack-track-stack-file)
+
+;; Add a designator to the minor mode strings
+(or (assq 'py-pdbtrack-is-tracking-p minor-mode-alist)
+    (push '(py-pdbtrack-is-tracking-p py-pdbtrack-minor-mode-string)
+	  minor-mode-alist))
+
+
+
+;;; paragraph and string filling code from Bernhard Herzog
+;;; see <A HREF="http://mail.python.org/pipermail/python-list/2002-May/103189.html">http://mail.python.org/pipermail/python-list/2002-May/103189.html</A>
+
+(defun py-fill-comment (&amp;optional justify)
+  &quot;Fill the comment paragraph around point&quot;
+  (let (;; Non-nil if the current line contains a comment.
+	has-comment
+
+	;; If has-comment, the appropriate fill-prefix for the comment.
+	comment-fill-prefix)
+
+    ;; Figure out what kind of comment we are looking at.
+    (save-excursion
+      (beginning-of-line)
+      (cond
+       ;; A line with nothing but a comment on it?
+       ((looking-at &quot;[ \t]*#[# \t]*&quot;)
+	(setq has-comment t
+	      comment-fill-prefix (buffer-substring (match-beginning 0)
+						    (match-end 0))))
+
+       ;; A line with some code, followed by a comment? Remember that the hash
+       ;; which starts the comment shouldn't be part of a string or character.
+       ((progn
+	  (while (not (looking-at &quot;#\\|$&quot;))
+	    (skip-chars-forward &quot;^#\n\&quot;'\\&quot;)
+	    (cond
+	     ((eq (char-after (point)) ?\\) (forward-char 2))
+	     ((memq (char-after (point)) '(?\&quot; ?')) (forward-sexp 1))))
+	  (looking-at &quot;#+[\t ]*&quot;))
+	(setq has-comment t)
+	(setq comment-fill-prefix
+	      (concat (make-string (current-column) ? )
+		      (buffer-substring (match-beginning 0) (match-end 0)))))))
+
+    (if (not has-comment)
+	(fill-paragraph justify)
+
+      ;; Narrow to include only the comment, and then fill the region.
+      (save-restriction
+	(narrow-to-region
+
+	 ;; Find the first line we should include in the region to fill.
+	 (save-excursion
+	   (while (and (zerop (forward-line -1))
+		       (looking-at &quot;^[ \t]*#&quot;)))
+
+	   ;; We may have gone to far.  Go forward again.
+	   (or (looking-at &quot;^[ \t]*#&quot;)
+	       (forward-line 1))
+	   (point))
+
+	 ;; Find the beginning of the first line past the region to fill.
+	 (save-excursion
+	   (while (progn (forward-line 1)
+			 (looking-at &quot;^[ \t]*#&quot;)))
+	   (point)))
+
+	;; Lines with only hashes on them can be paragraph boundaries.
+	(let ((paragraph-start (concat paragraph-start &quot;\\|[ \t#]*$&quot;))
+	      (paragraph-separate (concat paragraph-separate &quot;\\|[ \t#]*$&quot;))
+	      (fill-prefix comment-fill-prefix))
+	  ;;(message &quot;paragraph-start %S paragraph-separate %S&quot;
+	  ;;paragraph-start paragraph-separate)
+	  (fill-paragraph justify))))
+    t))
+
+
+(defun py-fill-string (start &amp;optional justify)
+  &quot;Fill the paragraph around (point) in the string starting at start&quot;
+  ;; basic strategy: narrow to the string and call the default
+  ;; implementation
+  (let (;; the start of the string's contents
+	string-start
+	;; the end of the string's contents
+	string-end
+	;; length of the string's delimiter
+	delim-length
+	;; The string delimiter
+	delim
+	)
+
+    (save-excursion
+      (goto-char start)
+      (if (looking-at &quot;\\('''\\|\&quot;\&quot;\&quot;\\|'\\|\&quot;\\)\\\\?\n?&quot;)
+	  (setq string-start (match-end 0)
+		delim-length (- (match-end 1) (match-beginning 1))
+		delim (buffer-substring-no-properties (match-beginning 1)
+						      (match-end 1)))
+	(error &quot;The parameter start is not the beginning of a python string&quot;))
+
+      ;; if the string is the first token on a line and doesn't start with
+      ;; a newline, fill as if the string starts at the beginning of the
+      ;; line. this helps with one line docstrings
+      (save-excursion
+	(beginning-of-line)
+	(and (/= (char-before string-start) ?\n)
+	     (looking-at (concat &quot;[ \t]*&quot; delim))
+	     (setq string-start (point))))
+
+      (forward-sexp (if (= delim-length 3) 2 1))
+
+      ;; with both triple quoted strings and single/double quoted strings
+      ;; we're now directly behind the first char of the end delimiter
+      ;; (this doesn't work correctly when the triple quoted string
+      ;; contains the quote mark itself). The end of the string's contents
+      ;; is one less than point
+      (setq string-end (1- (point))))
+
+    ;; Narrow to the string's contents and fill the current paragraph
+    (save-restriction
+      (narrow-to-region string-start string-end)
+      (let ((ends-with-newline (= (char-before (point-max)) ?\n)))
+	(fill-paragraph justify)
+	(if (and (not ends-with-newline)
+		 (= (char-before (point-max)) ?\n))
+	    ;; the default fill-paragraph implementation has inserted a
+	    ;; newline at the end. Remove it again.
+	    (save-excursion
+	      (goto-char (point-max))
+	      (delete-char -1)))))
+
+    ;; return t to indicate that we've done our work
+    t))
+
+(defun py-fill-paragraph (&amp;optional justify)
+  &quot;Like \\[fill-paragraph], but handle Python comments and strings.
+If any of the current line is a comment, fill the comment or the
+paragraph of it that point is in, preserving the comment's indentation
+and initial `#'s.
+If point is inside a string, narrow to that string and fill.
+&quot;
+  (interactive &quot;P&quot;)
+  (let* ((bod (py-point 'bod))
+	 (pps (parse-partial-sexp bod (point))))
+    (cond
+     ;; are we inside a comment or on a line with only whitespace before
+     ;; the comment start?
+     ((or (nth 4 pps)
+	  (save-excursion (beginning-of-line) (looking-at &quot;[ \t]*#&quot;)))
+      (py-fill-comment justify))
+     ;; are we inside a string?
+     ((nth 3 pps)
+      (py-fill-string (nth 8 pps)))
+     ;; are we at the opening quote of a string, or in the indentation?
+     ((save-excursion
+	(forward-word 1)
+	(eq (py-in-literal) 'string))
+      (save-excursion
+	(py-fill-string (py-point 'boi))))
+     ;; are we at or after the closing quote of a string?
+     ((save-excursion
+	(backward-word 1)
+	(eq (py-in-literal) 'string))
+      (save-excursion
+	(py-fill-string (py-point 'boi))))
+     ;; otherwise use the default
+     (t
+      (fill-paragraph justify)))))
+
+
+
+(provide 'python-mode)
+;;; python-mode.el ends here


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000000.html">[Gappy-svn] Google Groups: You've been added to DukeOSSHouseCourse
</A></li>
	<LI>Next message: <A HREF="000002.html">[Gappy-svn] r3 - trunk/support
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1">[ date ]</a>
              <a href="thread.html#1">[ thread ]</a>
              <a href="subject.html#1">[ subject ]</a>
              <a href="author.html#1">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/gappy-svn">More information about the Gappy-svn
mailing list</a><br>
</body></html>
